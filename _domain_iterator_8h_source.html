<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Max-Sum: include/DomainIterator.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<h1>include/DomainIterator.h</h1><a href="_domain_iterator_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00007"></a>00007 <span class="preprocessor">#ifndef MAXSUM_DOMAIN_ITERATOR_H</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#define MAXSUM_DOMAIN_ITERATOR_H</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "<a class="code" href="common_8h.html" title="Common types and functions used by Max-Sum library.">common.h</a>"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="register_8h.html" title="This Header defines functions for registering the set of all variables on which maxsum::DiscreteFunc...">register.h</a>"</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="keyword">namespace </span>maxsum
<a name="l00016"></a>00016 {
<a name="l00017"></a>00017    <span class="comment">// This declaration is required for constructor declaration.</span>
<a name="l00018"></a>00018    <span class="comment">// Can't simply include DiscreteFunction.h due to circular reference.</span>
<a name="l00019"></a>00019    <span class="keyword">class </span>DiscreteFunction; 
<a name="l00020"></a>00020 
<a name="l00025"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html">00025</a>    <span class="keyword">class </span><a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a>
<a name="l00026"></a>00026    {
<a name="l00027"></a>00027    <span class="keyword">public</span>: 
<a name="l00028"></a>00028 
<a name="l00032"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#12f9803d253b3b063608a2ec8ca705c4">00032</a>       <span class="keyword">typedef</span> std::vector&lt;VarID&gt; <a class="code" href="classmaxsum_1_1_domain_iterator.html#12f9803d253b3b063608a2ec8ca705c4" title="Type of list returned by DomainIterator::getVars().">VarList</a>;
<a name="l00033"></a>00033 
<a name="l00037"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#43c4ce2190270cf83cee4ee13e13e37c">00037</a>       <span class="keyword">typedef</span> std::vector&lt;ValIndex&gt; <a class="code" href="classmaxsum_1_1_domain_iterator.html#43c4ce2190270cf83cee4ee13e13e37c" title="Type of list returned by DomainIterator::getSubInd().">IndList</a>;
<a name="l00038"></a>00038 
<a name="l00045"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#a94438034a428503bbca3b883b493f0b">00045</a>       <span class="keywordtype">void</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#a94438034a428503bbca3b883b493f0b" title="Utility method that throws an exception if we try to access beyond the end of the...">validateRange</a>()<span class="keyword"> const</span>
<a name="l00046"></a>00046 <span class="keyword">      </span>{
<a name="l00047"></a>00047          <span class="keywordflow">if</span>(finished_i)
<a name="l00048"></a>00048          {
<a name="l00049"></a>00049             <span class="keywordflow">throw</span> <a class="code" href="classmaxsum_1_1_out_of_range_exception.html" title="Exception thrown when indices are out of range.">OutOfRangeException</a>(<span class="stringliteral">"DomainIterator"</span>,
<a name="l00050"></a>00050                   <span class="stringliteral">"Iterator is out of range."</span>);
<a name="l00051"></a>00051          }
<a name="l00052"></a>00052       }
<a name="l00053"></a>00053 
<a name="l00054"></a>00054    <span class="keyword">private</span>:
<a name="l00055"></a>00055 
<a name="l00059"></a>00059       <a class="code" href="classmaxsum_1_1_domain_iterator.html#12f9803d253b3b063608a2ec8ca705c4" title="Type of list returned by DomainIterator::getVars().">VarList</a> vars_i;
<a name="l00060"></a>00060 
<a name="l00064"></a>00064       <a class="code" href="classmaxsum_1_1_domain_iterator.html#43c4ce2190270cf83cee4ee13e13e37c" title="Type of list returned by DomainIterator::getSubInd().">IndList</a> subInd_i;
<a name="l00065"></a>00065 
<a name="l00069"></a>00069       <a class="code" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> ind_i;
<a name="l00070"></a>00070 
<a name="l00076"></a>00076       std::vector&lt;bool&gt; fixed_i;
<a name="l00077"></a>00077 
<a name="l00081"></a>00081       <a class="code" href="classmaxsum_1_1_domain_iterator.html#43c4ce2190270cf83cee4ee13e13e37c" title="Type of list returned by DomainIterator::getSubInd().">IndList</a> sizes_i;
<a name="l00082"></a>00082 
<a name="l00087"></a>00087       <span class="keywordtype">bool</span> finished_i;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089    <span class="keyword">public</span>:
<a name="l00090"></a>00090 
<a name="l00098"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#437136d49d51e0521043dbb935e341e1">00098</a>       <a class="code" href="classmaxsum_1_1_domain_iterator.html#437136d49d51e0521043dbb935e341e1" title="Default Constructor.">DomainIterator</a>() : vars_i(), subInd_i(), ind_i(0), fixed_i(),
<a name="l00099"></a>00099                          sizes_i(), finished_i(false) {}
<a name="l00100"></a>00100 
<a name="l00107"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#e1852204523ab600c44513ec05bdd323">00107</a>       <span class="keyword">template</span>&lt;<span class="keyword">class</span> It&gt; <a class="code" href="classmaxsum_1_1_domain_iterator.html#437136d49d51e0521043dbb935e341e1" title="Default Constructor.">DomainIterator</a>(It begin, It end)
<a name="l00108"></a>00108          : vars_i(begin,end),        <span class="comment">// copy variables</span>
<a name="l00109"></a>00109            subInd_i(end-begin,0),    <span class="comment">// set all subindices to zero</span>
<a name="l00110"></a>00110            ind_i(0),                 <span class="comment">// set linear index to zero</span>
<a name="l00111"></a>00111            fixed_i(end-begin,false), <span class="comment">// all variables are initially free</span>
<a name="l00112"></a>00112            sizes_i(end-begin,0),     <span class="comment">// allocate space for variable sizes</span>
<a name="l00113"></a>00113            finished_i(false)         <span class="comment">// iterator is not done yet</span>
<a name="l00114"></a>00114       {
<a name="l00115"></a>00115          <span class="comment">//*********************************************************************</span>
<a name="l00116"></a>00116          <span class="comment">// Ensure that the variable list is sorted</span>
<a name="l00117"></a>00117          <span class="comment">//*********************************************************************</span>
<a name="l00118"></a>00118          std::sort(vars_i.begin(),vars_i.end());
<a name="l00119"></a>00119 
<a name="l00120"></a>00120          <span class="comment">//*********************************************************************</span>
<a name="l00121"></a>00121          <span class="comment">// Most of the work here is done by the initialiser list.</span>
<a name="l00122"></a>00122          <span class="comment">// All we have to do now is populate the size array.</span>
<a name="l00123"></a>00123          <span class="comment">//*********************************************************************</span>
<a name="l00124"></a>00124          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;vars_i.size(); ++k)
<a name="l00125"></a>00125          {
<a name="l00126"></a>00126             sizes_i[k] = <a class="code" href="namespacemaxsum.html#de765a9ed8efa0721c739716c88d2ffd" title="Returns the domain size for a specified variable.">getDomainSize</a>(vars_i[k]);
<a name="l00127"></a>00127          }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129       } <span class="comment">// constructor</span>
<a name="l00130"></a>00130 
<a name="l00136"></a>00136       <a class="code" href="classmaxsum_1_1_domain_iterator.html#437136d49d51e0521043dbb935e341e1" title="Default Constructor.">DomainIterator</a>(<span class="keyword">const</span> <a class="code" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>&amp; fun);
<a name="l00137"></a>00137 
<a name="l00141"></a>00141       <a class="code" href="classmaxsum_1_1_domain_iterator.html#437136d49d51e0521043dbb935e341e1" title="Default Constructor.">DomainIterator</a>(<span class="keyword">const</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a>&amp; it);
<a name="l00142"></a>00142 
<a name="l00146"></a>00146       <a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a>&amp; <a class="code" href="classmaxsum_1_1_domain_iterator.html#bbe2b7ac6e65127d530386e80dd38365" title="Copy assignment.">operator=</a>(<span class="keyword">const</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a>&amp; it);
<a name="l00147"></a>00147 
<a name="l00156"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#166e3728bd0dd62a6d7e747baa2f16d9">00156</a>       <span class="keywordtype">bool</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#166e3728bd0dd62a6d7e747baa2f16d9" title="Returns true if next call to DomainIterator::operator++() will not throw an exception...">hasNext</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !finished_i; }
<a name="l00157"></a>00157 
<a name="l00162"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#8c964687d955a18800ec7b12d61095c6">00162</a>       <span class="keyword">const</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#43c4ce2190270cf83cee4ee13e13e37c" title="Type of list returned by DomainIterator::getSubInd().">IndList</a>&amp; <a class="code" href="classmaxsum_1_1_domain_iterator.html#8c964687d955a18800ec7b12d61095c6" title="Accessor method for current sub indices.">getSubInd</a>()<span class="keyword"> const</span>
<a name="l00163"></a>00163 <span class="keyword">      </span>{
<a name="l00164"></a>00164          <a class="code" href="classmaxsum_1_1_domain_iterator.html#a94438034a428503bbca3b883b493f0b" title="Utility method that throws an exception if we try to access beyond the end of the...">validateRange</a>();
<a name="l00165"></a>00165          <span class="keywordflow">return</span> subInd_i;
<a name="l00166"></a>00166       }
<a name="l00167"></a>00167       
<a name="l00172"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#129eac8f3a20d3d923afa082db6f165f">00172</a>       <a class="code" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> <a class="code" href="classmaxsum_1_1_domain_iterator.html#129eac8f3a20d3d923afa082db6f165f" title="Accessor method for linear index.">getInd</a>()<span class="keyword"> const</span>
<a name="l00173"></a>00173 <span class="keyword">      </span>{
<a name="l00174"></a>00174          <a class="code" href="classmaxsum_1_1_domain_iterator.html#a94438034a428503bbca3b883b493f0b" title="Utility method that throws an exception if we try to access beyond the end of the...">validateRange</a>();
<a name="l00175"></a>00175          <span class="keywordflow">return</span> ind_i;
<a name="l00176"></a>00176       }
<a name="l00177"></a>00177 
<a name="l00181"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#dd51774cbefb6ba5775451a505ea5f05">00181</a>       <span class="keyword">const</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#12f9803d253b3b063608a2ec8ca705c4" title="Type of list returned by DomainIterator::getVars().">VarList</a>&amp; <a class="code" href="classmaxsum_1_1_domain_iterator.html#dd51774cbefb6ba5775451a505ea5f05" title="Accessor method for variables in domain.">getVars</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vars_i; }
<a name="l00182"></a>00182 
<a name="l00187"></a>00187       <span class="keywordtype">bool</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#75bbb51446982d5981cb87769feb235d" title="Returns true if this function is conditioned on the specified variable.">isFixed</a>(<a class="code" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">VarID</a> var) <span class="keyword">const</span>;
<a name="l00188"></a>00188 
<a name="l00192"></a>00192       <span class="keywordtype">int</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#8a8132a1c367da10f225074bd4ffd018" title="Returns the number of conditioned variables for this function.">fixedCount</a>() <span class="keyword">const</span>;
<a name="l00193"></a>00193 
<a name="l00205"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#bbe491c6ec898909624bdf438c9c00ac">00205</a>       <span class="keyword">template</span>&lt;<span class="keyword">class</span> It&gt; <span class="keywordtype">void</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#bbe491c6ec898909624bdf438c9c00ac" title="Add the specified variables to the domain of this iterator.">addVars</a>(It begin, It end)
<a name="l00206"></a>00206       {
<a name="l00207"></a>00207          <span class="comment">//*********************************************************************</span>
<a name="l00208"></a>00208          <span class="comment">// Construct the new variable list, ensuring that it is sorted and</span>
<a name="l00209"></a>00209          <span class="comment">// does not contain duplicates.</span>
<a name="l00210"></a>00210          <span class="comment">//*********************************************************************</span>
<a name="l00211"></a>00211          std::vector&lt;VarID&gt; newVars = vars_i;
<a name="l00212"></a>00212          <span class="keywordtype">int</span> maxSize = (end - begin) + vars_i.size();
<a name="l00213"></a>00213          newVars.reserve(maxSize);
<a name="l00214"></a>00214          newVars.insert(newVars.end(),begin,end);
<a name="l00215"></a>00215          std::sort(newVars.begin(),newVars.end());
<a name="l00216"></a>00216 
<a name="l00217"></a>00217          std::vector&lt;VarID&gt;::iterator newEnd =
<a name="l00218"></a>00218             std::unique(newVars.begin(),newVars.end());
<a name="l00219"></a>00219 
<a name="l00220"></a>00220          newVars.resize(newEnd-newVars.begin());
<a name="l00221"></a>00221 
<a name="l00222"></a>00222          <span class="comment">//*********************************************************************</span>
<a name="l00223"></a>00223          <span class="comment">// Expand the indice, fixed and size arrays with initial values for</span>
<a name="l00224"></a>00224          <span class="comment">// all new variables.</span>
<a name="l00225"></a>00225          <span class="comment">//*********************************************************************</span>
<a name="l00226"></a>00226          <span class="keywordtype">int</span> pos = 0; <span class="comment">// position in old variable list</span>
<a name="l00227"></a>00227          std::vector&lt;ValIndex&gt; newSizes(newVars.size());
<a name="l00228"></a>00228          std::vector&lt;ValIndex&gt; newSubInd(newVars.size());
<a name="l00229"></a>00229          std::vector&lt;bool&gt; newFixed(newVars.size());
<a name="l00230"></a>00230 
<a name="l00231"></a>00231          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;newVars.size(); k++)
<a name="l00232"></a>00232          {
<a name="l00233"></a>00233             <span class="comment">//******************************************************************</span>
<a name="l00234"></a>00234             <span class="comment">// If the current variable is already in the domain, then</span>
<a name="l00235"></a>00235             <span class="comment">// copy its original state.</span>
<a name="l00236"></a>00236             <span class="comment">//******************************************************************</span>
<a name="l00237"></a>00237             <span class="keywordflow">if</span>( (pos&lt;vars_i.size()) &amp;&amp; (vars_i[pos] == newVars[k]) )
<a name="l00238"></a>00238             {
<a name="l00239"></a>00239                newSizes[k] = sizes_i[pos];
<a name="l00240"></a>00240                newSubInd[k] = subInd_i[pos];
<a name="l00241"></a>00241                newFixed[k] = fixed_i[pos];
<a name="l00242"></a>00242                ++pos;
<a name="l00243"></a>00243             }
<a name="l00244"></a>00244             <span class="comment">//******************************************************************</span>
<a name="l00245"></a>00245             <span class="comment">// Otherwise give it a new initial state</span>
<a name="l00246"></a>00246             <span class="comment">//******************************************************************</span>
<a name="l00247"></a>00247             <span class="keywordflow">else</span>
<a name="l00248"></a>00248             {
<a name="l00249"></a>00249                newSizes[k] = <a class="code" href="namespacemaxsum.html#de765a9ed8efa0721c739716c88d2ffd" title="Returns the domain size for a specified variable.">getDomainSize</a>(newVars[k]);
<a name="l00250"></a>00250                newSubInd[k] = 0;
<a name="l00251"></a>00251                newFixed[k] = <span class="keyword">false</span>;
<a name="l00252"></a>00252             }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254          } <span class="comment">// for loop</span>
<a name="l00255"></a>00255 
<a name="l00256"></a>00256          <span class="comment">//*********************************************************************</span>
<a name="l00257"></a>00257          <span class="comment">// Set the linear index to its appropriate value based on the</span>
<a name="l00258"></a>00258          <span class="comment">// updated subindices and sizes.</span>
<a name="l00259"></a>00259          <span class="comment">//*********************************************************************</span>
<a name="l00260"></a>00260          ind_i = <a class="code" href="namespacemaxsum.html#ffa32c842f83bd6e88a55a2adb92869b" title="C++ Implementation of Matlab sub2ind function.">sub2ind</a>( sizes_i.begin(),  sizes_i.end(),
<a name="l00261"></a>00261                          subInd_i.begin(), subInd_i.end() );
<a name="l00262"></a>00262 
<a name="l00263"></a>00263          <span class="comment">//*********************************************************************</span>
<a name="l00264"></a>00264          <span class="comment">// Since we've returned to the first element in the free part of the</span>
<a name="l00265"></a>00265          <span class="comment">// domain, DomainIterator::hasNext() should return true.</span>
<a name="l00266"></a>00266          <span class="comment">//*********************************************************************</span>
<a name="l00267"></a>00267          finished_i = <span class="keyword">false</span>;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269          <span class="comment">//*********************************************************************</span>
<a name="l00270"></a>00270          <span class="comment">// Finally, we swap in the new variable list.</span>
<a name="l00271"></a>00271          <span class="comment">//*********************************************************************</span>
<a name="l00272"></a>00272          vars_i.swap(newVars);
<a name="l00273"></a>00273          sizes_i.swap(newSizes);
<a name="l00274"></a>00274          subInd_i.swap(newSubInd);
<a name="l00275"></a>00275          fixed_i.swap(newFixed);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277       } <span class="comment">// function addVars</span>
<a name="l00278"></a>00278 
<a name="l00285"></a>00285       <a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a>&amp; <a class="code" href="classmaxsum_1_1_domain_iterator.html#6087706f3428194f4831eed309ee9e8b" title="Increment this iterator to the next element in the domain.">operator++</a>();
<a name="l00286"></a>00286 
<a name="l00293"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#b554cba7fd8ba72c5dd3cafd73273c41">00293</a>       <a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a> <a class="code" href="classmaxsum_1_1_domain_iterator.html#6087706f3428194f4831eed309ee9e8b" title="Increment this iterator to the next element in the domain.">operator++</a>(<span class="keywordtype">int</span>)
<a name="l00294"></a>00294       {
<a name="l00295"></a>00295          <a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a> copy(*<span class="keyword">this</span>);
<a name="l00296"></a>00296          ++(*this);
<a name="l00297"></a>00297          <span class="keywordflow">return</span> copy;
<a name="l00298"></a>00298       }
<a name="l00299"></a>00299 
<a name="l00321"></a>00321       <span class="keyword">template</span>&lt;<span class="keyword">class</span> VarIt, <span class="keyword">class</span> IndIt&gt; <span class="keywordtype">void</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#13bee254c182fc2bd7608c75fc0a9506" title="Condition domain on specified variable values.">condition</a>
<a name="l00322"></a><a class="code" href="classmaxsum_1_1_domain_iterator.html#13bee254c182fc2bd7608c75fc0a9506">00322</a>       (
<a name="l00323"></a>00323        <span class="keyword">const</span> VarIt varBegin,
<a name="l00324"></a>00324        <span class="keyword">const</span> VarIt varEnd,
<a name="l00325"></a>00325        <span class="keyword">const</span> IndIt indBegin,
<a name="l00326"></a>00326        <span class="keyword">const</span> IndIt indEnd
<a name="l00327"></a>00327       )
<a name="l00328"></a>00328       {
<a name="l00329"></a>00329          <span class="comment">//*********************************************************************</span>
<a name="l00330"></a>00330          <span class="comment">// Set the specified conditions for any variables that are in</span>
<a name="l00331"></a>00331          <span class="comment">// this domain.</span>
<a name="l00332"></a>00332          <span class="comment">//*********************************************************************</span>
<a name="l00333"></a>00333          VarIt pInVar = varBegin;
<a name="l00334"></a>00334          IndIt pInd = indBegin;
<a name="l00335"></a>00335          <span class="keywordflow">while</span>( (varEnd != pInVar) &amp;&amp; (indEnd != pInd) )
<a name="l00336"></a>00336          {
<a name="l00337"></a>00337             <span class="comment">//******************************************************************</span>
<a name="l00338"></a>00338             <span class="comment">// If the current variable is in our domain, condition its value</span>
<a name="l00339"></a>00339             <span class="comment">// as specified.</span>
<a name="l00340"></a>00340             <span class="comment">//******************************************************************</span>
<a name="l00341"></a>00341             std::vector&lt;VarID&gt;::const_iterator pMyVar =
<a name="l00342"></a>00342                find(vars_i.begin(),vars_i.end(),*pInVar);
<a name="l00343"></a>00343 
<a name="l00344"></a>00344             <span class="keywordflow">if</span>(vars_i.end() != pMyVar)
<a name="l00345"></a>00345             {
<a name="l00346"></a>00346                <span class="keywordtype">int</span> position = pMyVar - vars_i.begin();
<a name="l00347"></a>00347                 fixed_i[position] = <span class="keyword">true</span>;
<a name="l00348"></a>00348                subInd_i[position] = *pInd;
<a name="l00349"></a>00349             }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351             <span class="comment">//******************************************************************</span>
<a name="l00352"></a>00352             <span class="comment">// Move to next variable in argument list</span>
<a name="l00353"></a>00353             <span class="comment">//******************************************************************</span>
<a name="l00354"></a>00354             ++pInVar;
<a name="l00355"></a>00355             ++pInd;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357          } <span class="comment">// loop</span>
<a name="l00358"></a>00358 
<a name="l00359"></a>00359          <span class="comment">//*********************************************************************</span>
<a name="l00360"></a>00360          <span class="comment">// Set free indices back to zero. (This is a much easier policy to </span>
<a name="l00361"></a>00361          <span class="comment">// implement that trying to pick up were we left off.)</span>
<a name="l00362"></a>00362          <span class="comment">//*********************************************************************</span>
<a name="l00363"></a>00363          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k&lt;subInd_i.size(); ++k)
<a name="l00364"></a>00364          {
<a name="l00365"></a>00365             <span class="keywordflow">if</span>(!fixed_i[k])
<a name="l00366"></a>00366             {
<a name="l00367"></a>00367                subInd_i[k]=0;
<a name="l00368"></a>00368             }
<a name="l00369"></a>00369          }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371          <span class="comment">//*********************************************************************</span>
<a name="l00372"></a>00372          <span class="comment">// Since the free variables have been reset, the iterator is not</span>
<a name="l00373"></a>00373          <span class="comment">// finished. Notice, even if there are now free variables, we</span>
<a name="l00374"></a>00374          <span class="comment">// still intend to return the conditioned values at least once before</span>
<a name="l00375"></a>00375          <span class="comment">// finishing.</span>
<a name="l00376"></a>00376          <span class="comment">//*********************************************************************</span>
<a name="l00377"></a>00377          finished_i = <span class="keyword">false</span>;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379          <span class="comment">//*********************************************************************</span>
<a name="l00380"></a>00380          <span class="comment">// Set the linear index to its apropriate value, based on the</span>
<a name="l00381"></a>00381          <span class="comment">// conditioned variables.</span>
<a name="l00382"></a>00382          <span class="comment">//*********************************************************************</span>
<a name="l00383"></a>00383          ind_i = <a class="code" href="namespacemaxsum.html#ffa32c842f83bd6e88a55a2adb92869b" title="C++ Implementation of Matlab sub2ind function.">sub2ind</a>( sizes_i.begin(),  sizes_i.end(),
<a name="l00384"></a>00384                          subInd_i.begin(), subInd_i.end() );
<a name="l00385"></a>00385 
<a name="l00386"></a>00386       } <span class="comment">// function condition</span>
<a name="l00387"></a>00387 
<a name="l00399"></a>00399       <span class="keywordtype">void</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html#13bee254c182fc2bd7608c75fc0a9506" title="Condition domain on specified variable values.">condition</a>(<span class="keyword">const</span> <a class="code" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of...">DomainIterator</a>&amp; it);
<a name="l00400"></a>00400 
<a name="l00401"></a>00401    }; <span class="comment">// class DomainIterator</span>
<a name="l00402"></a>00402 
<a name="l00403"></a>00403 } <span class="comment">// namespace maxsum</span>
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="preprocessor">#endif // MAXSUM_DOMAIN_ITERATOR_H</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 30 17:00:02 2012 for Max-Sum by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
