<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Max-Sum: maxsum Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>maxsum Namespace Reference</h1>Namespace for all public types and functions defined by the Max-Sum library.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum_1_1util.html">util</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility namespace for types used for <a class="el" href="namespacemaxsum.html" title="Namespace for all public types and functions defined by the Max-Sum library.">maxsum</a> library implementation. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_no_such_element_exception.html">NoSuchElementException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when there has been an attempt to access an element of a container that does not exist, and cannot be created on demand.  <a href="classmaxsum_1_1_no_such_element_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_empty_notice_exception.html">EmptyNoticeException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown by <a class="el" href="classmaxsum_1_1_post_office.html#555b273abb421ad73ca6327ee34ce35c" title="Returns the identity of the next receiver who has new mail, and removes their identity...">PostOffice::popNotice</a> when there are no active notices.  <a href="classmaxsum_1_1_empty_notice_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_unknown_address_exception.html">UnknownAddressException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when a <a class="el" href="classmaxsum_1_1_post_office.html" title="Class used to store and manage messages sent between factor graph nodes.">maxsum::PostOffice</a> does not recognise the ID of a Sender or Receiver.  <a href="classmaxsum_1_1_unknown_address_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_bad_domain_exception.html">BadDomainException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when subindices are incorrectly specified for a function.  <a href="classmaxsum_1_1_bad_domain_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_out_of_range_exception.html">OutOfRangeException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when indices are out of range.  <a href="classmaxsum_1_1_out_of_range_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_domain_conflict_exception.html">DomainConflictException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown conflicting domains are specified for a variable.  <a href="classmaxsum_1_1_domain_conflict_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_unknown_variable_exception.html">UnknownVariableException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when a variable is not registered.  <a href="classmaxsum_1_1_unknown_variable_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_inconsistent_domain_exception.html">InconsistentDomainException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when variable domains are inconsistent.  <a href="classmaxsum_1_1_inconsistent_domain_exception.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing functions of sets of variables with discrete domains.  <a href="classmaxsum_1_1_discrete_function.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_domain_iterator.html">DomainIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides methods for iterating over the Cartesian product for a set of variable domains.  <a href="classmaxsum_1_1_domain_iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_max_sum_controller.html">MaxSumController</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class maintains a factor graph and implements the max-sum algorithm.  <a href="classmaxsum_1_1_max_sum_controller.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_post_office.html">PostOffice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class used to store and manage messages sent between factor graph nodes.  <a href="classmaxsum_1_1_post_office.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd02fc7a161c705a735b15646b2b6733"></a><!-- doxytag: member="maxsum::ValType" ref="dd02fc7a161c705a735b15646b2b6733" args="" -->
typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#dd02fc7a161c705a735b15646b2b6733">ValType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of values stored by <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216">VarID</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type used for uniquely identifying variables.  <a href="#572e59b0c017dac30927fc445aa28216"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#2bce04bab0e368fa664de701b05b3690">FactorID</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type used for uniquely identifying factors in a factor graph.  <a href="#2bce04bab0e368fa664de701b05b3690"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2703843fa0f76002b3285d94f1693d26"></a><!-- doxytag: member="maxsum::ValIndex" ref="2703843fa0f76002b3285d94f1693d26" args="" -->
typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26">ValIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Integer type used for indexing coefficient values. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e7cfade9f4781ff4a5d74397b584980"></a><!-- doxytag: member="maxsum::V2FPostOffice" ref="7e7cfade9f4781ff4a5d74397b584980" args="" -->
typedef <a class="el" href="classmaxsum_1_1_post_office.html">PostOffice</a>&lt; <a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216">VarID</a>, <br class="typebreak">
<a class="el" href="namespacemaxsum.html#2bce04bab0e368fa664de701b05b3690">FactorID</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#7e7cfade9f4781ff4a5d74397b584980">V2FPostOffice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef for Variable to Factor PostOffices. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6cc54b9fce21b60cf66dca62e5f06fc3"></a><!-- doxytag: member="maxsum::F2VPostOffice" ref="6cc54b9fce21b60cf66dca62e5f06fc3" args="" -->
typedef <a class="el" href="classmaxsum_1_1_post_office.html">PostOffice</a>&lt; <a class="el" href="namespacemaxsum.html#2bce04bab0e368fa664de701b05b3690">FactorID</a>, <br class="typebreak">
<a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216">VarID</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#6cc54b9fce21b60cf66dca62e5f06fc3">F2VPostOffice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef for Factor to Variable PostOffices. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba3b3b89155eeec99cff8f330fe9948b"></a><!-- doxytag: member="maxsum::F2FPostOffice" ref="ba3b3b89155eeec99cff8f330fe9948b" args="" -->
typedef <a class="el" href="classmaxsum_1_1_post_office.html">PostOffice</a>&lt; <a class="el" href="namespacemaxsum.html#2bce04bab0e368fa664de701b05b3690">FactorID</a>, <br class="typebreak">
<a class="el" href="namespacemaxsum.html#2bce04bab0e368fa664de701b05b3690">FactorID</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ba3b3b89155eeec99cff8f330fe9948b">F2FPostOffice</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience typedef for Factor to Factor PostOffices. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VecType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#e5522a3acac209d3d528f95dacf54fdd">ind2sub</a> (const VecType &amp;siz, const typename VecType::value_type ind, VecType &amp;sub)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C++ Implementation of Matlab ind2sub function.  <a href="#e5522a3acac209d3d528f95dacf54fdd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class SizIt , class SubIt &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26">ValIndex</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ffa32c842f83bd6e88a55a2adb92869b">sub2ind</a> (SizIt sizFirst, SizIt sizEnd, SubIt subFirst, SubIt subEnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C++ Implementation of Matlab sub2ind function.  <a href="#ffa32c842f83bd6e88a55a2adb92869b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VecType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">VecType::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#77d4e8cfbf7177fec4eb2c23d80dedab">sub2ind</a> (const VecType &amp;siz, const VecType &amp;sub)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C++ Implementation of Matlab sub2ind function.  <a href="#77d4e8cfbf7177fec4eb2c23d80dedab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#5a71b4f9ef67a9784db88235c47938ae">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;fun)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pretty prints a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> Format is similar to the disp function in Matlab for N-D arrays, except that first dimension appears in rows rather than columns.  <a href="#5a71b4f9ef67a9784db88235c47938ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#15f2209735d087f5f25c68f9cb1778b0">sameDomain</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects have the same domain.  <a href="#15f2209735d087f5f25c68f9cb1778b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#6386d78723ee3d5d0202f05c2a3c7726">equalWithinTolerance</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2, <a class="el" href="namespacemaxsum.html#dd02fc7a161c705a735b15646b2b6733">ValType</a> tol=<a class="el" href="namespacemaxsum.html#accbd5a77a4dc529b8f5eaa0f75d2599">DEFAULT_VALUE_TOLERANCE</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal within a specified tolerance.  <a href="#6386d78723ee3d5d0202f05c2a3c7726"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#0e6948dba163b8d6a51a41f2ea24a182">strictlyEqualWithinTolerance</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2, <a class="el" href="namespacemaxsum.html#dd02fc7a161c705a735b15646b2b6733">ValType</a> tol=<a class="el" href="namespacemaxsum.html#accbd5a77a4dc529b8f5eaa0f75d2599">DEFAULT_VALUE_TOLERANCE</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal with a specified tolerance, and have exactly the same domain.  <a href="#0e6948dba163b8d6a51a41f2ea24a182"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#1fe4e49dd8b9a04cc840c939451d8d31">operator==</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if functions are equal.  <a href="#1fe4e49dd8b9a04cc840c939451d8d31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#211d534ea5c729b936b5c29247531cee">operator!=</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if functions are equal.  <a href="#211d534ea5c729b936b5c29247531cee"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#b8d7cf2af7956238312e792aff5f189d">marginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, F aggregate, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> using a specified aggregation function.  <a href="#b8d7cf2af7956238312e792aff5f189d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#219e2e817c1601121cdb149147c14abc">maxMarginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by maximisation.  <a href="#219e2e817c1601121cdb149147c14abc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#3a82ee0162acb2c89417e5365be4f854">minMarginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by minimisation.  <a href="#3a82ee0162acb2c89417e5365be4f854"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#555aaedda317f2d7a06fedd8c0636d5c">meanMarginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by averaging.  <a href="#555aaedda317f2d7a06fedd8c0636d5c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ebc836fb9ee564bd66f6e79caa621060"></a><!-- doxytag: member="maxsum::operator&lt;&lt;" ref="ebc836fb9ee564bd66f6e79caa621060" args="(std::ostream &amp;out, const MaxSumController &amp;controller)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ebc836fb9ee564bd66f6e79caa621060">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmaxsum_1_1_max_sum_controller.html">MaxSumController</a> &amp;controller)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility function used to dump the current state of this controller for debugging purposes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#c0ae7ef092d533a1fc99ce719b6e3312">isRegistered</a> (<a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216">VarID</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the specified variable is registered.  <a href="#c0ae7ef092d533a1fc99ce719b6e3312"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VarIt &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#4b68389cc816fbd21b26d095f36d5eec">allRegistered</a> (VarIt varBegin, VarIt varEnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if all specified variables are registered.  <a href="#4b68389cc816fbd21b26d095f36d5eec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26">ValIndex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#de765a9ed8efa0721c739716c88d2ffd">getDomainSize</a> (<a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216">VarID</a> var)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the domain size for a specified variable.  <a href="#de765a9ed8efa0721c739716c88d2ffd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#3aa8891b3c2d966a1345beedfe9e92e1">getNumOfRegisteredVariables</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of currently registered variables.  <a href="#3aa8891b3c2d966a1345beedfe9e92e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#373fa742a9678cc654e76384cb04d7b0">registerVariable</a> (<a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216">VarID</a> var, <a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26">ValIndex</a> siz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a variable with a specified domain size.  <a href="#373fa742a9678cc654e76384cb04d7b0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class VarIt , class IndIt &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ff3430f57716ae0462e67978157a18aa">registerVariables</a> (VarIt varBegin, VarIt varEnd, IndIt sizBegin, IndIt sizEnd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a list of variables with specified domain sizes.  <a href="#ff3430f57716ae0462e67978157a18aa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="namespacemaxsum.html#dd02fc7a161c705a735b15646b2b6733">ValType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#accbd5a77a4dc529b8f5eaa0f75d2599">DEFAULT_VALUE_TOLERANCE</a> = DBL_EPSILON * 1000.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default tolerance used for comparing values of type <a class="el" href="namespacemaxsum.html#dd02fc7a161c705a735b15646b2b6733" title="Type of values stored by maxsum::DiscreteFunction objects.">maxsum::ValType</a>.  <a href="#accbd5a77a4dc529b8f5eaa0f75d2599"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Namespace for all public types and functions defined by the Max-Sum library. 
<p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="2bce04bab0e368fa664de701b05b3690"></a><!-- doxytag: member="maxsum::FactorID" ref="2bce04bab0e368fa664de701b05b3690" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacemaxsum.html#2bce04bab0e368fa664de701b05b3690">maxsum::FactorID</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type used for uniquely identifying factors in a factor graph. 
<p>
This is purposely an integer type - want this to be efficient for storing and passing between functions. Note, bitwise operations can be used in some addressing schemes, e.g. something like IP addresses. 
</div>
</div><p>
<a class="anchor" name="572e59b0c017dac30927fc445aa28216"></a><!-- doxytag: member="maxsum::VarID" ref="572e59b0c017dac30927fc445aa28216" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216">maxsum::VarID</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type used for uniquely identifying variables. 
<p>
This is purposely an integer type - want this to be efficient for storing and passing between functions. Note, bitwise operations can be used in some addressing schemes, e.g. something like IP addresses. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="4b68389cc816fbd21b26d095f36d5eec"></a><!-- doxytag: member="maxsum::allRegistered" ref="4b68389cc816fbd21b26d095f36d5eec" args="(VarIt varBegin, VarIt varEnd)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VarIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::allRegistered           </td>
          <td>(</td>
          <td class="paramtype">VarIt&nbsp;</td>
          <td class="paramname"> <em>varBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarIt&nbsp;</td>
          <td class="paramname"> <em>varEnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if all specified variables are registered. 
<p>
Paramters are iterators over a list of variable ids, or type <a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>varBegin</em>&nbsp;</td><td>iterator to begining of variable list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>varEnd</em>&nbsp;</td><td>iterator to end of variable list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if all registered, false otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6386d78723ee3d5d0202f05c2a3c7726"></a><!-- doxytag: member="maxsum::equalWithinTolerance" ref="6386d78723ee3d5d0202f05c2a3c7726" args="(const DiscreteFunction &amp;f1, const DiscreteFunction &amp;f2, ValType tol=DEFAULT_VALUE_TOLERANCE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::equalWithinTolerance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValType&nbsp;</td>
          <td class="paramname"> <em>tol</em> = <code>DEFAULT_VALUE_TOLERANCE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal within a specified tolerance. 
<p>
This function returns true if and only if, for all <code>k</code>: <p>
<code> -tol &lt; 1-f1(k)/f2(k) &lt; tol </code>  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f1</em>&nbsp;</td><td>First function to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f2</em>&nbsp;</td><td>Second function to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tol</em>&nbsp;</td><td>tolerance used for comparing values </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#accbd5a77a4dc529b8f5eaa0f75d2599" title="Default tolerance used for comparing values of type maxsum::ValType.">maxsum::DEFAULT_VALUE_TOLERANCE</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="de765a9ed8efa0721c739716c88d2ffd"></a><!-- doxytag: member="maxsum::getDomainSize" ref="de765a9ed8efa0721c739716c88d2ffd" args="(VarID var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26">maxsum::ValIndex</a> maxsum::getDomainSize           </td>
          <td>(</td>
          <td class="paramtype">VarID&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the domain size for a specified variable. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>id of the variable to search for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>domain size of var </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmaxsum_1_1_unknown_variable_exception.html" title="Exception thrown when a variable is not registered.">UnknownVariableException</a></em>&nbsp;</td><td>if variable is not registered. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3aa8891b3c2d966a1345beedfe9e92e1"></a><!-- doxytag: member="maxsum::getNumOfRegisteredVariables" ref="3aa8891b3c2d966a1345beedfe9e92e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maxsum::getNumOfRegisteredVariables           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of currently registered variables. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of currently registered variables. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5522a3acac209d3d528f95dacf54fdd"></a><!-- doxytag: member="maxsum::ind2sub" ref="e5522a3acac209d3d528f95dacf54fdd" args="(const VecType &amp;siz, const typename VecType::value_type ind, VecType &amp;sub)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::ind2sub           </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&nbsp;</td>
          <td class="paramname"> <em>siz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename VecType::value_type&nbsp;</td>
          <td class="paramname"> <em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecType &amp;&nbsp;</td>
          <td class="paramname"> <em>sub</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C++ Implementation of Matlab ind2sub function. 
<p>
Main difference here is that indices start from 0. In the special case where siz is empty, ind will also be empty. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>siz</em>&nbsp;</td><td>of N-D array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ind</em>&nbsp;</td><td>linear index </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sub</em>&nbsp;</td><td>vector in which we will put the sub indices. </td></tr>
  </table>
</dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>previous contents of sub will be overwritten. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c0ae7ef092d533a1fc99ce719b6e3312"></a><!-- doxytag: member="maxsum::isRegistered" ref="c0ae7ef092d533a1fc99ce719b6e3312" args="(VarID var)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::isRegistered           </td>
          <td>(</td>
          <td class="paramtype">VarID&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the specified variable is registered. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>id of the variable to search for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the specified variable is registered.<p>
true if the specified variable is registered. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8d7cf2af7956238312e792aff5f189d"></a><!-- doxytag: member="maxsum::marginal" ref="b8d7cf2af7956238312e792aff5f189d" args="(const DiscreteFunction &amp;inFun, F aggregate, DiscreteFunction &amp;outFun)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::marginal           </td>
          <td>(</td>
          <td class="paramtype">const DiscreteFunction &amp;&nbsp;</td>
          <td class="paramname"> <em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction &amp;&nbsp;</td>
          <td class="paramname"> <em>outFun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> using a specified aggregation function. 
<p>
This function reduces the domain of <code>inFun</code> to that of <code>outFun</code> and stores the result in <code>outFun</code>. This is done by aggregating over all variables that are in the domain of <code>inFun</code>, but not in the domain of <code>outFun</code>. <p>
Aggregation is performed by a functor or function pointer, <code>aggregate</code>, which is passed as a template parameter. <code>aggregate</code> should be defined such that, in the code below, <code>z</code> is the aggregation of the function values <code>x</code> and <code>y</code>. <pre>
 ValType x = inFun(k);
 ValType y = inFun(t);
 ValType z = aggregate(x,y); // result = aggregate(prevResult,nextVal)
 </pre> <p>
Note that aggregate may be a function pointer, or any other object for which the above syntax is valid, such as a class instance that overloads the () operator, which may depend some internal state. The first argument to aggregate should always be the previous estimate, while the second is always the next value to be aggregated. <p>
Various specialisations of this function are provided by <a class="el" href="namespacemaxsum.html#219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a>, <a class="el" href="namespacemaxsum.html#3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a>, <a class="el" href="namespacemaxsum.html#555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a>. <p>
In the special case where the domain of outFun is equal to the domain of inFun, outFun becomes a copy of inFun <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>aggregate is a functor with signature <code>ValType aggregate(ValType prevResult, ValType nextVal)</code> <p>
variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>previous content of outFun is overwritten. <p>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>F</em>&nbsp;</td><td>type of parameter aggregate. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inFun</em>&nbsp;</td><td>function to marginalise </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aggregate</em>&nbsp;</td><td>functor or function pointer used to aggregate results. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outFun</em>&nbsp;</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a function.">maxsum::BadDomainException</a></em>&nbsp;</td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> <p>
<a class="el" href="namespacemaxsum.html#3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a> <p>
<a class="el" href="namespacemaxsum.html#555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="219e2e817c1601121cdb149147c14abc"></a><!-- doxytag: member="maxsum::maxMarginal" ref="219e2e817c1601121cdb149147c14abc" args="(const DiscreteFunction &amp;inFun, DiscreteFunction &amp;outFun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::maxMarginal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outFun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by maximisation. 
<p>
This function reduces the domain of inFun to that of outFun by maximisation, and stores the result in outFun. This behaviour is equivalent to maxsum::marginal(inFun,std::max&lt;ValType&gt;,outFun). <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>previous content of outFun is overwritten. <p>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inFun</em>&nbsp;</td><td>function to marginalise </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outFun</em>&nbsp;</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a function.">maxsum::BadDomainException</a></em>&nbsp;</td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#b8d7cf2af7956238312e792aff5f189d" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> <p>
<a class="el" href="namespacemaxsum.html#3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a> <p>
<a class="el" href="namespacemaxsum.html#555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="555aaedda317f2d7a06fedd8c0636d5c"></a><!-- doxytag: member="maxsum::meanMarginal" ref="555aaedda317f2d7a06fedd8c0636d5c" args="(const DiscreteFunction &amp;inFun, DiscreteFunction &amp;outFun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::meanMarginal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outFun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by averaging. 
<p>
This function reduces the domain of inFun to that of outFun by averaging, and stores the result in outFun. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>previous content of outFun is overwritten. <p>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inFun</em>&nbsp;</td><td>function to marginalise </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outFun</em>&nbsp;</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a function.">maxsum::BadDomainException</a></em>&nbsp;</td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#b8d7cf2af7956238312e792aff5f189d" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> <p>
<a class="el" href="namespacemaxsum.html#3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a> <p>
<a class="el" href="namespacemaxsum.html#219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a82ee0162acb2c89417e5365be4f854"></a><!-- doxytag: member="maxsum::minMarginal" ref="3a82ee0162acb2c89417e5365be4f854" args="(const DiscreteFunction &amp;inFun, DiscreteFunction &amp;outFun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::minMarginal           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outFun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by minimisation. 
<p>
Marginal a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by minimisation.<p>
This function reduces the domain of inFun to that of outFun by minimisation, and stores the result in outFun. This behaviour is equivalent to maxsum::marginal(inFun,std::min&lt;ValType&gt;,outFun). <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>previous content of outFun is overwritten. <p>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inFun</em>&nbsp;</td><td>function to marginalise </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outFun</em>&nbsp;</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a function.">maxsum::BadDomainException</a></em>&nbsp;</td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#b8d7cf2af7956238312e792aff5f189d" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> <p>
<a class="el" href="namespacemaxsum.html#219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> <p>
<a class="el" href="namespacemaxsum.html#555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a></dd></dl>
This function reduces the domain of inFun to that of outFun by minimisation, and stores the result in outFun. This behaviour is equivalent to maxsum::marginal(inFun,std::min&lt;ValType&gt;,outFun). <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="post" compact><dt><b>Postcondition:</b></dt><dd>previous content of outFun is overwritten. <p>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inFun</em>&nbsp;</td><td>function to marginalise </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a function.">maxsum::BadDomainException</a></em>&nbsp;</td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outFun</em>&nbsp;</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#b8d7cf2af7956238312e792aff5f189d" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> <p>
<a class="el" href="namespacemaxsum.html#219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> <p>
<a class="el" href="namespacemaxsum.html#555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="211d534ea5c729b936b5c29247531cee"></a><!-- doxytag: member="maxsum::operator!=" ref="211d534ea5c729b936b5c29247531cee" args="(const DiscreteFunction &amp;f1, const DiscreteFunction &amp;f2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const DiscreteFunction &amp;&nbsp;</td>
          <td class="paramname"> <em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiscreteFunction &amp;&nbsp;</td>
          <td class="paramname"> <em>f2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if functions are equal. 
<p>
Two functions are equal if they have the same value over the cartesian product of their domains. 
</div>
</div><p>
<a class="anchor" name="5a71b4f9ef67a9784db88235c47938ae"></a><!-- doxytag: member="maxsum::operator&lt;&lt;" ref="5a71b4f9ef67a9784db88235c47938ae" args="(std::ostream &amp;out, const DiscreteFunction &amp;fun)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; maxsum::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fun</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pretty prints a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> Format is similar to the disp function in Matlab for N-D arrays, except that first dimension appears in rows rather than columns. 
<p>
Pretty prints a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a>.<p>
Pretty prints this function.<p>
Format is similar to the disp function in Matlab for N-D arrays, except that first dimension appears in rows rather than columns. 
</div>
</div><p>
<a class="anchor" name="1fe4e49dd8b9a04cc840c939451d8d31"></a><!-- doxytag: member="maxsum::operator==" ref="1fe4e49dd8b9a04cc840c939451d8d31" args="(const DiscreteFunction &amp;f1, const DiscreteFunction &amp;f2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::operator==           </td>
          <td>(</td>
          <td class="paramtype">const DiscreteFunction &amp;&nbsp;</td>
          <td class="paramname"> <em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiscreteFunction &amp;&nbsp;</td>
          <td class="paramname"> <em>f2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return true if functions are equal. 
<p>
Two functions are equal if they have the same value over the cartesian product of their domains. This 
</div>
</div><p>
<a class="anchor" name="373fa742a9678cc654e76384cb04d7b0"></a><!-- doxytag: member="maxsum::registerVariable" ref="373fa742a9678cc654e76384cb04d7b0" args="(VarID var, ValIndex siz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::registerVariable           </td>
          <td>(</td>
          <td class="paramtype">VarID&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValIndex&nbsp;</td>
          <td class="paramname"> <em>siz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a variable with a specified domain size. 
<p>
Put the specified variable in a global register, and stores its domain size. Variables can be registered multiple times, but their domain size must never change. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classmaxsum_1_1_inconsistent_domain_exception.html" title="Exception thrown when variable domains are inconsistent.">InconsistentDomainException</a></em>&nbsp;</td><td>if this variable is already registered, but with a different domain size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the unique id of this variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>siz</em>&nbsp;</td><td>the domain size of this variable </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ff3430f57716ae0462e67978157a18aa"></a><!-- doxytag: member="maxsum::registerVariables" ref="ff3430f57716ae0462e67978157a18aa" args="(VarIt varBegin, VarIt varEnd, IndIt sizBegin, IndIt sizEnd)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VarIt , class IndIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::registerVariables           </td>
          <td>(</td>
          <td class="paramtype">VarIt&nbsp;</td>
          <td class="paramname"> <em>varBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarIt&nbsp;</td>
          <td class="paramname"> <em>varEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndIt&nbsp;</td>
          <td class="paramname"> <em>sizBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndIt&nbsp;</td>
          <td class="paramname"> <em>sizEnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a list of variables with specified domain sizes. 
<p>
This works in the same was as <a class="el" href="namespacemaxsum.html#373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">maxsum::registerVariable</a> - but does so for multiple variables at a time. The parameters varBegin and varEnd are iterators to the beginning and end of a list of variable ids, while sizBegin and sizEnd specify the start and end of a list of their respective domain sizes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>varBegin</em>&nbsp;</td><td>iterator to the start of a list of <a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>varEnd</em>&nbsp;</td><td>iterator to the end of a list of <a class="el" href="namespacemaxsum.html#572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sizBegin</em>&nbsp;</td><td>iterator to the start of a list of <a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sizEnd</em>&nbsp;</td><td>iterator to the start of a list of <a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">maxsum::registerVariable</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="15f2209735d087f5f25c68f9cb1778b0"></a><!-- doxytag: member="maxsum::sameDomain" ref="15f2209735d087f5f25c68f9cb1778b0" args="(const DiscreteFunction &amp;f1, const DiscreteFunction &amp;f2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::sameDomain           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects have the same domain. 
<p>
Two functions have the same domain, if they depend on the same set of variables. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f1</em>&nbsp;</td><td>First function to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f2</em>&nbsp;</td><td>Second functions to compare </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if both function have the same domain. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e6948dba163b8d6a51a41f2ea24a182"></a><!-- doxytag: member="maxsum::strictlyEqualWithinTolerance" ref="0e6948dba163b8d6a51a41f2ea24a182" args="(const DiscreteFunction &amp;f1, const DiscreteFunction &amp;f2, ValType tol=DEFAULT_VALUE_TOLERANCE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::strictlyEqualWithinTolerance           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValType&nbsp;</td>
          <td class="paramname"> <em>tol</em> = <code>DEFAULT_VALUE_TOLERANCE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal with a specified tolerance, and have exactly the same domain. 
<p>
This function returns true if and only if: <p>
<code> true == sameDomain(f1,f2) &amp;&amp; equalWithinTolerance(f1,f2,tol) </code>  <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f1</em>&nbsp;</td><td>First function to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>f2</em>&nbsp;</td><td>Second function to compare </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tol</em>&nbsp;</td><td>tolerance used for comparing values </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="namespacemaxsum.html#accbd5a77a4dc529b8f5eaa0f75d2599" title="Default tolerance used for comparing values of type maxsum::ValType.">maxsum::DEFAULT_VALUE_TOLERANCE</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="77d4e8cfbf7177fec4eb2c23d80dedab"></a><!-- doxytag: member="maxsum::sub2ind" ref="77d4e8cfbf7177fec4eb2c23d80dedab" args="(const VecType &amp;siz, const VecType &amp;sub)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VecType::value_type maxsum::sub2ind           </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&nbsp;</td>
          <td class="paramname"> <em>siz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecType &amp;&nbsp;</td>
          <td class="paramname"> <em>sub</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C++ Implementation of Matlab sub2ind function. 
<p>
Main difference here is that indices start from 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>siz</em>&nbsp;</td><td>of N-D array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sub</em>&nbsp;</td><td>empty vector in which we will put the sub indices. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>linear index </dd></dl>

</div>
</div><p>
<a class="anchor" name="ffa32c842f83bd6e88a55a2adb92869b"></a><!-- doxytag: member="maxsum::sub2ind" ref="ffa32c842f83bd6e88a55a2adb92869b" args="(SizIt sizFirst, SizIt sizEnd, SubIt subFirst, SubIt subEnd)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SizIt , class SubIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaxsum.html#2703843fa0f76002b3285d94f1693d26">ValIndex</a> maxsum::sub2ind           </td>
          <td>(</td>
          <td class="paramtype">SizIt&nbsp;</td>
          <td class="paramname"> <em>sizFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizIt&nbsp;</td>
          <td class="paramname"> <em>sizEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubIt&nbsp;</td>
          <td class="paramname"> <em>subFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubIt&nbsp;</td>
          <td class="paramname"> <em>subEnd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
C++ Implementation of Matlab sub2ind function. 
<p>
Main difference here is that indices start from 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sizFirst</em>&nbsp;</td><td>iterator to first element of size array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sizEnd</em>&nbsp;</td><td>iterator to end element of size array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subFirst</em>&nbsp;</td><td>iterator to first element of subindex array. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subEnd</em>&nbsp;</td><td>iterator to first element of subindex array. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>linear index </dd></dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="accbd5a77a4dc529b8f5eaa0f75d2599"></a><!-- doxytag: member="maxsum::DEFAULT_VALUE_TOLERANCE" ref="accbd5a77a4dc529b8f5eaa0f75d2599" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacemaxsum.html#dd02fc7a161c705a735b15646b2b6733">ValType</a> <a class="el" href="namespacemaxsum.html#accbd5a77a4dc529b8f5eaa0f75d2599">maxsum::DEFAULT_VALUE_TOLERANCE</a> = DBL_EPSILON * 1000.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default tolerance used for comparing values of type <a class="el" href="namespacemaxsum.html#dd02fc7a161c705a735b15646b2b6733" title="Type of values stored by maxsum::DiscreteFunction objects.">maxsum::ValType</a>. 
<p>
This is the default value used by the <a class="el" href="namespacemaxsum.html#6386d78723ee3d5d0202f05c2a3c7726" title="Check that two maxsum::DiscreteFunction objects are equal within a specified tolerance...">maxsum::equalWithinTolerance()</a> function, when comparing to <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects for equality. Note, if ValType is ever redefined, then this value should be changed appropriately also. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jul 30 17:00:02 2012 for Max-Sum by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
