<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Max-Sum: maxsum Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Max-Sum
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">maxsum Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for all public types and functions defined by the Max-Sum library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemaxsum_1_1util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacemaxsum_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility namespace for types used for maxsum library implementation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing functions of sets of variables with discrete domains.  <a href="classmaxsum_1_1_discrete_function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_domain_iterator.html">DomainIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides methods for iterating over the Cartesian product for a set of variable domains.  <a href="classmaxsum_1_1_domain_iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_no_such_element_exception.html">NoSuchElementException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when there has been an attempt to access an element of a container that does not exist, and cannot be created on demand.  <a href="classmaxsum_1_1_no_such_element_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_empty_notice_exception.html">EmptyNoticeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by <a class="el" href="classmaxsum_1_1util_1_1_post_office.html#a37f9e4c29a74d6babda93f359f05d8e1" title="Returns the identity of the next receiver who has new mail, and removes their identity from the notif...">maxsum::util::PostOffice::popNotice</a> when there are no active notices.  <a href="classmaxsum_1_1_empty_notice_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_unknown_address_exception.html">UnknownAddressException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a <a class="el" href="classmaxsum_1_1util_1_1_post_office.html" title="Class used to store and manage messages sent between factor graph nodes.">maxsum::util::PostOffice</a> does not recognise the ID of a Sender or Receiver.  <a href="classmaxsum_1_1_unknown_address_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_bad_domain_exception.html">BadDomainException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when subindices are incorrectly specified for a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a>.  <a href="classmaxsum_1_1_bad_domain_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_out_of_range_exception.html">OutOfRangeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when indices are out of range.  <a href="classmaxsum_1_1_out_of_range_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_domain_conflict_exception.html">DomainConflictException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when conflicting domains are specified for a variable.  <a href="classmaxsum_1_1_domain_conflict_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_unknown_variable_exception.html">UnknownVariableException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a variable is referred to, but has not yet been registered using either <a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">maxsum::registerVariable</a> or <a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">maxsum::registerVariables</a>.  <a href="classmaxsum_1_1_unknown_variable_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_inconsistent_domain_exception.html">InconsistentDomainException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when variable domains are somehow registered as inconsistent.  <a href="classmaxsum_1_1_inconsistent_domain_exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmaxsum_1_1_max_sum_controller.html">MaxSumController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class maintains a factor graph and implements the max-sum algorithm.  <a href="classmaxsum_1_1_max_sum_controller.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:add02fc7a161c705a735b15646b2b6733"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a></td></tr>
<tr class="memdesc:add02fc7a161c705a735b15646b2b6733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of values stored by <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects.  <a href="#add02fc7a161c705a735b15646b2b6733"></a><br/></td></tr>
<tr class="separator:add02fc7a161c705a735b15646b2b6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572e59b0c017dac30927fc445aa28216"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216">VarID</a></td></tr>
<tr class="memdesc:a572e59b0c017dac30927fc445aa28216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for uniquely identifying variables.  <a href="#a572e59b0c017dac30927fc445aa28216"></a><br/></td></tr>
<tr class="separator:a572e59b0c017dac30927fc445aa28216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bce04bab0e368fa664de701b05b3690"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a2bce04bab0e368fa664de701b05b3690">FactorID</a></td></tr>
<tr class="memdesc:a2bce04bab0e368fa664de701b05b3690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for uniquely identifying factors in a factor graph.  <a href="#a2bce04bab0e368fa664de701b05b3690"></a><br/></td></tr>
<tr class="separator:a2bce04bab0e368fa664de701b05b3690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2703843fa0f76002b3285d94f1693d26"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26">ValIndex</a></td></tr>
<tr class="memdesc:a2703843fa0f76002b3285d94f1693d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer type used for indexing coefficient values.  <a href="#a2703843fa0f76002b3285d94f1693d26"></a><br/></td></tr>
<tr class="separator:a2703843fa0f76002b3285d94f1693d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d3a9b87a36f8623fddc284a72c26b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74d3a9b87a36f8623fddc284a72c26b9"></a>
typedef <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a74d3a9b87a36f8623fddc284a72c26b9">UnaryScalarOp</a> )(const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>)</td></tr>
<tr class="memdesc:a74d3a9b87a36f8623fddc284a72c26b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type for operations applied to function values. <br/></td></tr>
<tr class="separator:a74d3a9b87a36f8623fddc284a72c26b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2708d6a667f2da516d353472599038"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd2708d6a667f2da516d353472599038"></a>
typedef <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#afd2708d6a667f2da516d353472599038">DualScalarOp</a> )(const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>, const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>)</td></tr>
<tr class="memdesc:afd2708d6a667f2da516d353472599038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type for operations applied to two functions. <br/></td></tr>
<tr class="separator:afd2708d6a667f2da516d353472599038"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afca9fa88d29e336f06162f301bde7e34"><td class="memTemplParams" colspan="2">template&lt;class VecType &gt; </td></tr>
<tr class="memitem:afca9fa88d29e336f06162f301bde7e34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#afca9fa88d29e336f06162f301bde7e34">ind2sub</a> (const VecType &amp;siz, const typename VecType::value_type ind, VecType &amp;sub)</td></tr>
<tr class="memdesc:afca9fa88d29e336f06162f301bde7e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Implementation of Matlab ind2sub function.  <a href="#afca9fa88d29e336f06162f301bde7e34"></a><br/></td></tr>
<tr class="separator:afca9fa88d29e336f06162f301bde7e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4fbdd98787e23c4f84437ac180ba57"><td class="memTemplParams" colspan="2">template&lt;class SizIt , class SubIt &gt; </td></tr>
<tr class="memitem:ada4fbdd98787e23c4f84437ac180ba57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26">ValIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ada4fbdd98787e23c4f84437ac180ba57">sub2ind</a> (SizIt sizFirst, SizIt sizEnd, SubIt subFirst, SubIt subEnd)</td></tr>
<tr class="memdesc:ada4fbdd98787e23c4f84437ac180ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Implementation of Matlab sub2ind function.  <a href="#ada4fbdd98787e23c4f84437ac180ba57"></a><br/></td></tr>
<tr class="separator:ada4fbdd98787e23c4f84437ac180ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64bfc6ed68463f979ee706972cc6f46"><td class="memTemplParams" colspan="2">template&lt;class VecType &gt; </td></tr>
<tr class="memitem:ac64bfc6ed68463f979ee706972cc6f46"><td class="memTemplItemLeft" align="right" valign="top">VecType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ac64bfc6ed68463f979ee706972cc6f46">sub2ind</a> (const VecType &amp;siz, const VecType &amp;sub)</td></tr>
<tr class="memdesc:ac64bfc6ed68463f979ee706972cc6f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Implementation of Matlab sub2ind function.  <a href="#ac64bfc6ed68463f979ee706972cc6f46"></a><br/></td></tr>
<tr class="separator:ac64bfc6ed68463f979ee706972cc6f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a71b4f9ef67a9784db88235c47938ae"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a5a71b4f9ef67a9784db88235c47938ae">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;fun)</td></tr>
<tr class="memdesc:a5a71b4f9ef67a9784db88235c47938ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty prints a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> Format is similar to the disp function in Matlab for N-D arrays, except that first dimension appears in rows rather than columns.  <a href="#a5a71b4f9ef67a9784db88235c47938ae"></a><br/></td></tr>
<tr class="separator:a5a71b4f9ef67a9784db88235c47938ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f2209735d087f5f25c68f9cb1778b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a15f2209735d087f5f25c68f9cb1778b0">sameDomain</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>
<tr class="memdesc:a15f2209735d087f5f25c68f9cb1778b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects have the same domain.  <a href="#a15f2209735d087f5f25c68f9cb1778b0"></a><br/></td></tr>
<tr class="separator:a15f2209735d087f5f25c68f9cb1778b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6386d78723ee3d5d0202f05c2a3c7726"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a6386d78723ee3d5d0202f05c2a3c7726">equalWithinTolerance</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2, <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a> tol=<a class="el" href="namespacemaxsum.html#aaccbd5a77a4dc529b8f5eaa0f75d2599">DEFAULT_VALUE_TOLERANCE</a>)</td></tr>
<tr class="memdesc:a6386d78723ee3d5d0202f05c2a3c7726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal within a specified tolerance.  <a href="#a6386d78723ee3d5d0202f05c2a3c7726"></a><br/></td></tr>
<tr class="separator:a6386d78723ee3d5d0202f05c2a3c7726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6948dba163b8d6a51a41f2ea24a182"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a0e6948dba163b8d6a51a41f2ea24a182">strictlyEqualWithinTolerance</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2, <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a> tol=<a class="el" href="namespacemaxsum.html#aaccbd5a77a4dc529b8f5eaa0f75d2599">DEFAULT_VALUE_TOLERANCE</a>)</td></tr>
<tr class="memdesc:a0e6948dba163b8d6a51a41f2ea24a182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal with a specified tolerance, and have exactly the same domain.  <a href="#a0e6948dba163b8d6a51a41f2ea24a182"></a><br/></td></tr>
<tr class="separator:a0e6948dba163b8d6a51a41f2ea24a182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe4e49dd8b9a04cc840c939451d8d31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a1fe4e49dd8b9a04cc840c939451d8d31">operator==</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>
<tr class="memdesc:a1fe4e49dd8b9a04cc840c939451d8d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if functions are equal.  <a href="#a1fe4e49dd8b9a04cc840c939451d8d31"></a><br/></td></tr>
<tr class="separator:a1fe4e49dd8b9a04cc840c939451d8d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211d534ea5c729b936b5c29247531cee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a211d534ea5c729b936b5c29247531cee">operator!=</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>
<tr class="memdesc:a211d534ea5c729b936b5c29247531cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if functions are equal.  <a href="#a211d534ea5c729b936b5c29247531cee"></a><br/></td></tr>
<tr class="separator:a211d534ea5c729b936b5c29247531cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b391a28df06ce79f41f63f4bc332c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b391a28df06ce79f41f63f4bc332c2"></a>
<a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a50b391a28df06ce79f41f63f4bc332c2">operator/</a> (const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a> f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>
<tr class="memdesc:a50b391a28df06ce79f41f63f4bc332c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peforms element-wise division of a scalar by a function. <br/></td></tr>
<tr class="separator:a50b391a28df06ce79f41f63f4bc332c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1aea11b0717927a8cdcf23787d84ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e1aea11b0717927a8cdcf23787d84ac"></a>
<a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a6e1aea11b0717927a8cdcf23787d84ac">operator*</a> (const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a> f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>
<tr class="memdesc:a6e1aea11b0717927a8cdcf23787d84ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peforms element-wise multiplication of a scalar by a function. <br/></td></tr>
<tr class="separator:a6e1aea11b0717927a8cdcf23787d84ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33771b43457c3831ff1615bfebfaa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf33771b43457c3831ff1615bfebfaa3"></a>
<a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#acf33771b43457c3831ff1615bfebfaa3">operator+</a> (const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a> f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>
<tr class="memdesc:acf33771b43457c3831ff1615bfebfaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peforms element-wise addition of a scalar by a function. <br/></td></tr>
<tr class="separator:acf33771b43457c3831ff1615bfebfaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10561c1b019a893b1e7c6db923298d4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10561c1b019a893b1e7c6db923298d4e"></a>
<a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a10561c1b019a893b1e7c6db923298d4e">operator-</a> (const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a> f1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;f2)</td></tr>
<tr class="memdesc:a10561c1b019a893b1e7c6db923298d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peforms element-wise subtraction of a function from a scalar. <br/></td></tr>
<tr class="separator:a10561c1b019a893b1e7c6db923298d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48b4828eefae581abf6b475b8d8f60c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ae48b4828eefae581abf6b475b8d8f60c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ae48b4828eefae581abf6b475b8d8f60c">marginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, F aggregate, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>
<tr class="memdesc:ae48b4828eefae581abf6b475b8d8f60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> using a specified aggregation function.  <a href="#ae48b4828eefae581abf6b475b8d8f60c"></a><br/></td></tr>
<tr class="separator:ae48b4828eefae581abf6b475b8d8f60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219e2e817c1601121cdb149147c14abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc">maxMarginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>
<tr class="memdesc:a219e2e817c1601121cdb149147c14abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by maximisation.  <a href="#a219e2e817c1601121cdb149147c14abc"></a><br/></td></tr>
<tr class="separator:a219e2e817c1601121cdb149147c14abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a82ee0162acb2c89417e5365be4f854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a3a82ee0162acb2c89417e5365be4f854">minMarginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>
<tr class="memdesc:a3a82ee0162acb2c89417e5365be4f854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by minimisation.  <a href="#a3a82ee0162acb2c89417e5365be4f854"></a><br/></td></tr>
<tr class="separator:a3a82ee0162acb2c89417e5365be4f854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555aaedda317f2d7a06fedd8c0636d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c">meanMarginal</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFun, <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;outFun)</td></tr>
<tr class="memdesc:a555aaedda317f2d7a06fedd8c0636d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by averaging.  <a href="#a555aaedda317f2d7a06fedd8c0636d5c"></a><br/></td></tr>
<tr class="separator:a555aaedda317f2d7a06fedd8c0636d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab28265477df4caef01d55fe16fbe45b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab28265477df4caef01d55fe16fbe45b"></a>
template&lt;UnaryScalarOp OP&gt; </td></tr>
<tr class="memitem:aab28265477df4caef01d55fe16fbe45b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#aab28265477df4caef01d55fe16fbe45b">elementWiseOp</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFcn)</td></tr>
<tr class="memdesc:aab28265477df4caef01d55fe16fbe45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template used to generate operations that apply some function to each of a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s values. <br/></td></tr>
<tr class="separator:aab28265477df4caef01d55fe16fbe45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09c60060946ab80f6fe61e764baee64"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab09c60060946ab80f6fe61e764baee64"></a>
template&lt;DualScalarOp OP&gt; </td></tr>
<tr class="memitem:ab09c60060946ab80f6fe61e764baee64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ab09c60060946ab80f6fe61e764baee64">elementWiseOp</a> (const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFcn1, const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;inFcn2)</td></tr>
<tr class="memdesc:ab09c60060946ab80f6fe61e764baee64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template used to generate operations that apply some operation to a pair of DiscreteFunctions. <br/></td></tr>
<tr class="separator:ab09c60060946ab80f6fe61e764baee64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f5f46d9bd619f1178ad39d827f913b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81f5f46d9bd619f1178ad39d827f913b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a81f5f46d9bd619f1178ad39d827f913b">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classmaxsum_1_1_max_sum_controller.html">MaxSumController</a> &amp;controller)</td></tr>
<tr class="memdesc:a81f5f46d9bd619f1178ad39d827f913b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function used to dump the current state of this controller for debugging purposes. <br/></td></tr>
<tr class="separator:a81f5f46d9bd619f1178ad39d827f913b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ae7ef092d533a1fc99ce719b6e3312"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ac0ae7ef092d533a1fc99ce719b6e3312">isRegistered</a> (<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216">VarID</a> var)</td></tr>
<tr class="memdesc:ac0ae7ef092d533a1fc99ce719b6e3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified variable is registered.  <a href="#ac0ae7ef092d533a1fc99ce719b6e3312"></a><br/></td></tr>
<tr class="separator:ac0ae7ef092d533a1fc99ce719b6e3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04cd773da715c2a62d428b511e311ab2"><td class="memTemplParams" colspan="2">template&lt;class VarIt &gt; </td></tr>
<tr class="memitem:a04cd773da715c2a62d428b511e311ab2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a04cd773da715c2a62d428b511e311ab2">allRegistered</a> (VarIt varBegin, VarIt varEnd)</td></tr>
<tr class="memdesc:a04cd773da715c2a62d428b511e311ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all specified variables are registered.  <a href="#a04cd773da715c2a62d428b511e311ab2"></a><br/></td></tr>
<tr class="separator:a04cd773da715c2a62d428b511e311ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade765a9ed8efa0721c739716c88d2ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26">ValIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#ade765a9ed8efa0721c739716c88d2ffd">getDomainSize</a> (<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216">VarID</a> var)</td></tr>
<tr class="memdesc:ade765a9ed8efa0721c739716c88d2ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the registered domain size for a specified variable.  <a href="#ade765a9ed8efa0721c739716c88d2ffd"></a><br/></td></tr>
<tr class="separator:ade765a9ed8efa0721c739716c88d2ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa8891b3c2d966a1345beedfe9e92e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a3aa8891b3c2d966a1345beedfe9e92e1">getNumOfRegisteredVariables</a> ()</td></tr>
<tr class="memdesc:a3aa8891b3c2d966a1345beedfe9e92e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of currently registered variables.  <a href="#a3aa8891b3c2d966a1345beedfe9e92e1"></a><br/></td></tr>
<tr class="separator:a3aa8891b3c2d966a1345beedfe9e92e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373fa742a9678cc654e76384cb04d7b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0">registerVariable</a> (<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216">VarID</a> var, <a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26">ValIndex</a> siz)</td></tr>
<tr class="memdesc:a373fa742a9678cc654e76384cb04d7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a variable with a specified domain size.  <a href="#a373fa742a9678cc654e76384cb04d7b0"></a><br/></td></tr>
<tr class="separator:a373fa742a9678cc654e76384cb04d7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bbaee58df9fdda98966952ad990c85"><td class="memTemplParams" colspan="2">template&lt;class VarIt , class IndIt &gt; </td></tr>
<tr class="memitem:a18bbaee58df9fdda98966952ad990c85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85">registerVariables</a> (VarIt varBegin, VarIt varEnd, IndIt sizBegin, IndIt sizEnd)</td></tr>
<tr class="memdesc:a18bbaee58df9fdda98966952ad990c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a list of variables with specified domain sizes.  <a href="#a18bbaee58df9fdda98966952ad990c85"></a><br/></td></tr>
<tr class="separator:a18bbaee58df9fdda98966952ad990c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aaccbd5a77a4dc529b8f5eaa0f75d2599"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemaxsum.html#aaccbd5a77a4dc529b8f5eaa0f75d2599">DEFAULT_VALUE_TOLERANCE</a> = DBL_EPSILON * 1000.0</td></tr>
<tr class="memdesc:aaccbd5a77a4dc529b8f5eaa0f75d2599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tolerance used for comparing values of type <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733" title="Type of values stored by maxsum::DiscreteFunction objects.">maxsum::ValType</a>.  <a href="#aaccbd5a77a4dc529b8f5eaa0f75d2599"></a><br/></td></tr>
<tr class="separator:aaccbd5a77a4dc529b8f5eaa0f75d2599"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all public types and functions defined by the Max-Sum library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2bce04bab0e368fa664de701b05b3690"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacemaxsum.html#a2bce04bab0e368fa664de701b05b3690">maxsum::FactorID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for uniquely identifying factors in a factor graph. </p>
<p>This is purposely an integer type, because we want this to be efficient for storing and passing between functions. Note: bitwise operations can be used in some addressing schemes, e.g. something like IP addresses. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2703843fa0f76002b3285d94f1693d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26">maxsum::ValIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer type used for indexing coefficient values. </p>
<p>This is the value type for all variables that are referenced an identified using <a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a>. In particular, if a value of type <a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> is specified for each variable in a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> object's domain, then exactly one value of type <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733" title="Type of values stored by maxsum::DiscreteFunction objects.">maxsum::ValType</a> will be returned by element accessor functions, such as <a class="el" href="classmaxsum_1_1_discrete_function.html#a7cc147d43c4e523d54a0601150e1954b" title="Access coefficient using scalar index.">maxsum::DiscreteFunction::at</a> </p>

</div>
</div>
<a class="anchor" id="add02fc7a161c705a735b15646b2b6733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">maxsum::ValType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of values stored by <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects. </p>
<p>This is, this type is used to represent the codomain of mathematical functions represented by <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a572e59b0c017dac30927fc445aa28216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216">maxsum::VarID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type used for uniquely identifying variables. </p>
<p>This is purposely an integer type, because we want this to be efficient for storing and passing between functions. Note: bitwise operations can be used in some addressing schemes, e.g. something like IP addresses. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#a2bce04bab0e368fa664de701b05b3690" title="Type used for uniquely identifying factors in a factor graph.">maxsum::FactorID</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a04cd773da715c2a62d428b511e311ab2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VarIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::allRegistered </td>
          <td>(</td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>varBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>varEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if all specified variables are registered. </p>
<p>Parameters are iterators over a list of variable ids of type <a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varBegin</td><td>iterator to begining of variable list. </td></tr>
    <tr><td class="paramname">varEnd</td><td>iterator to end of variable list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all registered, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6386d78723ee3d5d0202f05c2a3c7726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::equalWithinTolerance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>DEFAULT_VALUE_TOLERANCE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal within a specified tolerance. </p>
<p>This function returns true if and only if, for all <code>k</code>: </p>
<p><code> -tol &lt; 1-f1(k)/f2(k) &lt; tol </code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f1</td><td>First function to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f2</td><td>Second function to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>tolerance used for comparing values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#aaccbd5a77a4dc529b8f5eaa0f75d2599" title="Default tolerance used for comparing values of type maxsum::ValType.">maxsum::DEFAULT_VALUE_TOLERANCE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade765a9ed8efa0721c739716c88d2ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26">maxsum::ValIndex</a> maxsum::getDomainSize </td>
          <td>(</td>
          <td class="paramtype">VarID&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the registered domain size for a specified variable. </p>
<p>Returns the domain size for a specified variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>id of the variable to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>domain size of var </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_unknown_variable_exception.html" title="Exception thrown when a variable is referred to, but has not yet been registered using either maxsum:...">UnknownVariableException</a></td><td>if the variable is not registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>id of the variable to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>domain size of var </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_unknown_variable_exception.html" title="Exception thrown when a variable is referred to, but has not yet been registered using either maxsum:...">UnknownVariableException</a></td><td>if variable is not registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3aa8891b3c2d966a1345beedfe9e92e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maxsum::getNumOfRegisteredVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of currently registered variables. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of currently registered variables. </dd></dl>

</div>
</div>
<a class="anchor" id="afca9fa88d29e336f06162f301bde7e34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::ind2sub </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>siz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename VecType::value_type&#160;</td>
          <td class="paramname"><em>ind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecType &amp;&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Implementation of Matlab ind2sub function. </p>
<p>Main difference here is that indices start from 0. In the special case where siz is empty, ind will also be empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">siz</td><td>of N-D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ind</td><td>linear index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sub</td><td>vector in which we will put the sub indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>previous contents of sub will be overwritten. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0ae7ef092d533a1fc99ce719b6e3312"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::isRegistered </td>
          <td>(</td>
          <td class="paramtype">VarID&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified variable is registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>id of the variable to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the specified variable is registered.</dd>
<dd>
true if the specified variable is registered. </dd></dl>

</div>
</div>
<a class="anchor" id="ae48b4828eefae581abf6b475b8d8f60c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::marginal </td>
          <td>(</td>
          <td class="paramtype">const DiscreteFunction &amp;&#160;</td>
          <td class="paramname"><em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiscreteFunction &amp;&#160;</td>
          <td class="paramname"><em>outFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> using a specified aggregation function. </p>
<p>This function reduces the domain of <code>inFun</code> to that of <code>outFun</code> and stores the result in <code>outFun</code>. This is done by aggregating over all variables that are in the domain of <code>inFun</code>, but not in the domain of <code>outFun</code>. </p>
<p>Aggregation is performed by a functor or function pointer, <code>aggregate</code>, which is passed as a template parameter. <code>aggregate</code> should be defined such that, in the code below, <code>z</code> is the aggregation of the function values <code>x</code> and <code>y</code>.</p>
<pre>
ValType x = inFun(k);
ValType y = inFun(t);
ValType z = aggregate(x,y); // result = aggregate(prevResult,nextVal)
</pre> <p>Note that aggregate may be a function pointer, or any other object for which the above syntax is valid, such as a class instance that overloads the () operator, which may depend some internal state. The first argument to aggregate should always be the previous estimate, while the second is always the next value to be aggregated.</p>
<p>Various specialisations of this function are provided by <a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a>, <a class="el" href="namespacemaxsum.html#a3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a>, <a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a>.</p>
<p>In the special case where the domain of outFun is equal to the domain of inFun, outFun becomes a copy of inFun</p>
<dl class="section pre"><dt>Precondition</dt><dd>aggregate is a functor with signature <code>ValType aggregate(ValType prevResult, ValType nextVal)</code> </dd>
<dd>
variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>previous content of outFun is overwritten. </dd>
<dd>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>type of parameter aggregate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inFun</td><td>function to marginalise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aggregate</td><td>functor or function pointer used to aggregate results. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outFun</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a maxsum::DiscreteFunction.">maxsum::BadDomainException</a></td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a219e2e817c1601121cdb149147c14abc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::maxMarginal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>outFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by maximisation. </p>
<p>This function reduces the domain of inFun to that of outFun by maximisation, and stores the result in outFun. This behaviour is equivalent to maxsum::marginal(inFun,std::max&lt;ValType&gt;,outFun). </p>
<dl class="section pre"><dt>Precondition</dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>previous content of outFun is overwritten. </dd>
<dd>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inFun</td><td>function to marginalise </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outFun</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a maxsum::DiscreteFunction.">maxsum::BadDomainException</a></td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#ae48b4828eefae581abf6b475b8d8f60c" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a555aaedda317f2d7a06fedd8c0636d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::meanMarginal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>outFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by averaging. </p>
<p>This function reduces the domain of inFun to that of outFun by averaging, and stores the result in outFun. </p>
<dl class="section pre"><dt>Precondition</dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>previous content of outFun is overwritten. </dd>
<dd>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inFun</td><td>function to marginalise </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outFun</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a maxsum::DiscreteFunction.">maxsum::BadDomainException</a></td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#ae48b4828eefae581abf6b475b8d8f60c" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">maxsum::minMarginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a82ee0162acb2c89417e5365be4f854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::minMarginal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>inFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>outFun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marginalise a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by minimisation. </p>
<p>Marginal a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> by minimisation.</p>
<p>This function reduces the domain of inFun to that of outFun by minimisation, and stores the result in outFun. This behaviour is equivalent to maxsum::marginal(inFun,std::min&lt;ValType&gt;,outFun). </p>
<dl class="section pre"><dt>Precondition</dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>previous content of outFun is overwritten. </dd>
<dd>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inFun</td><td>function to marginalise </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outFun</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a maxsum::DiscreteFunction.">maxsum::BadDomainException</a></td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#ae48b4828eefae581abf6b475b8d8f60c" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a></dd></dl>
<p>This function reduces the domain of inFun to that of outFun by minimisation, and stores the result in outFun. This behaviour is equivalent to maxsum::marginal(inFun,std::min&lt;ValType&gt;,outFun). </p>
<dl class="section pre"><dt>Precondition</dt><dd>variables in domain of outFun are a subset of variables in inFun. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>previous content of outFun is overwritten. </dd>
<dd>
The domains of outFun and inFun remain unchanged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inFun</td><td>function to marginalise </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_bad_domain_exception.html" title="Exception thrown when subindices are incorrectly specified for a maxsum::DiscreteFunction.">maxsum::BadDomainException</a></td><td>is the domain of outFun is not a subset of inFun. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">outFun</td><td><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> in which to store result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#ae48b4828eefae581abf6b475b8d8f60c" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">maxsum::marginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxsum::maxMarginal()</a> </dd>
<dd>
<a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">maxsum::meanMarginal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a211d534ea5c729b936b5c29247531cee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DiscreteFunction &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiscreteFunction &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if functions are equal. </p>
<p>Two functions are equal if they have the same value over the cartesian product of their domains. </p>

</div>
</div>
<a class="anchor" id="a5a71b4f9ef67a9784db88235c47938ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; maxsum::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty prints a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> Format is similar to the disp function in Matlab for N-D arrays, except that first dimension appears in rows rather than columns. </p>
<p>Pretty prints a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a>.</p>
<p>Pretty prints this function.</p>
<p>Format is similar to the disp function in Matlab for N-D arrays, except that first dimension appears in rows rather than columns. </p>

</div>
</div>
<a class="anchor" id="a1fe4e49dd8b9a04cc840c939451d8d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::operator== </td>
          <td>(</td>
          <td class="paramtype">const DiscreteFunction &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiscreteFunction &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if functions are equal. </p>
<p>Two functions are equal if they have the same value over the cartesian product of their domains. </p>

</div>
</div>
<a class="anchor" id="a373fa742a9678cc654e76384cb04d7b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::registerVariable </td>
          <td>(</td>
          <td class="paramtype">VarID&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValIndex&#160;</td>
          <td class="paramname"><em>siz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a variable with a specified domain size. </p>
<p>Puts the specified variable in a global register, and stores its domain size. Variables can be registered multiple times, but their domain size must never change. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_inconsistent_domain_exception.html" title="Exception thrown when variable domains are somehow registered as inconsistent.">InconsistentDomainException</a></td><td>if this variable is already registered, but with a different domain size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>the unique id of this variable </td></tr>
    <tr><td class="paramname">siz</td><td>the domain size of this variable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">maxsum::registerVariables</a></dd></dl>
<p>Put the specified variable in a global register, and stores its domain size. Variables can be registered multiple times, but their domain size must never change. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classmaxsum_1_1_inconsistent_domain_exception.html" title="Exception thrown when variable domains are somehow registered as inconsistent.">InconsistentDomainException</a></td><td>if this variable is already registered, but with a different domain size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>the unique id of this variable </td></tr>
    <tr><td class="paramname">siz</td><td>the domain size of this variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18bbaee58df9fdda98966952ad990c85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VarIt , class IndIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void maxsum::registerVariables </td>
          <td>(</td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>varBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarIt&#160;</td>
          <td class="paramname"><em>varEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndIt&#160;</td>
          <td class="paramname"><em>sizBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndIt&#160;</td>
          <td class="paramname"><em>sizEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a list of variables with specified domain sizes. </p>
<p>This works in the same was as <a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">maxsum::registerVariable</a> - but does so for multiple variables at a time. The parameters varBegin and varEnd are iterators to the beginning and end of a list of variable ids, while sizBegin and sizEnd specify the start and end of a list of their respective domain sizes. Both lists must be ordered such that the kth element of the size list is the domain size for the kth variable in the variable list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varBegin</td><td>iterator to the start of a list of <a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> </td></tr>
    <tr><td class="paramname">varEnd</td><td>iterator to the end of a list of <a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> </td></tr>
    <tr><td class="paramname">sizBegin</td><td>iterator to the start of a list of <a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> </td></tr>
    <tr><td class="paramname">sizEnd</td><td>iterator to the start of a list of <a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">maxsum::registerVariable</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a15f2209735d087f5f25c68f9cb1778b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::sameDomain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects have the same domain. </p>
<p>Two functions have the same domain, if they depend on the same set of variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f1</td><td>First function to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f2</td><td>Second functions to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both function have the same domain. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e6948dba163b8d6a51a41f2ea24a182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool maxsum::strictlyEqualWithinTolerance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmaxsum_1_1_discrete_function.html">DiscreteFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>DEFAULT_VALUE_TOLERANCE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that two <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects are equal with a specified tolerance, and have exactly the same domain. </p>
<p>This function returns true if and only if: </p>
<p><code> true == sameDomain(f1,f2) &amp;&amp; equalWithinTolerance(f1,f2,tol) </code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f1</td><td>First function to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f2</td><td>Second function to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>tolerance used for comparing values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#aaccbd5a77a4dc529b8f5eaa0f75d2599" title="Default tolerance used for comparing values of type maxsum::ValType.">maxsum::DEFAULT_VALUE_TOLERANCE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ada4fbdd98787e23c4f84437ac180ba57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class SizIt , class SubIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26">ValIndex</a> maxsum::sub2ind </td>
          <td>(</td>
          <td class="paramtype">SizIt&#160;</td>
          <td class="paramname"><em>sizFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizIt&#160;</td>
          <td class="paramname"><em>sizEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubIt&#160;</td>
          <td class="paramname"><em>subFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubIt&#160;</td>
          <td class="paramname"><em>subEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Implementation of Matlab sub2ind function. </p>
<p>Main difference here is that indices start from 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sizFirst</td><td>iterator to first element of size array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizEnd</td><td>iterator to end element of size array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subFirst</td><td>iterator to first element of subindex array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subEnd</td><td>iterator to first element of subindex array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear index </dd></dl>

</div>
</div>
<a class="anchor" id="ac64bfc6ed68463f979ee706972cc6f46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VecType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VecType::value_type maxsum::sub2ind </td>
          <td>(</td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>siz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecType &amp;&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C++ Implementation of Matlab sub2ind function. </p>
<p>Main difference here is that indices start from 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">siz</td><td>of N-D array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sub</td><td>empty vector in which we will put the sub indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>linear index </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aaccbd5a77a4dc529b8f5eaa0f75d2599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733">ValType</a> maxsum::DEFAULT_VALUE_TOLERANCE = DBL_EPSILON * 1000.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default tolerance used for comparing values of type <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733" title="Type of values stored by maxsum::DiscreteFunction objects.">maxsum::ValType</a>. </p>
<p>This is the default value used by the <a class="el" href="namespacemaxsum.html#a6386d78723ee3d5d0202f05c2a3c7726" title="Check that two maxsum::DiscreteFunction objects are equal within a specified tolerance.">maxsum::equalWithinTolerance</a> function, when comparing to <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> objects for equality. Note, if ValType is ever redefined, then this value should be changed appropriately also. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacemaxsum.html#a6386d78723ee3d5d0202f05c2a3c7726" title="Check that two maxsum::DiscreteFunction objects are equal within a specified tolerance.">maxsum::equalWithinTolerance</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 2 2013 08:48:19 for Max-Sum by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
