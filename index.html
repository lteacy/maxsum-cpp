<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Max-Sum: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Max-Sum
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Max-Sum Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Overview</a></li>
<li class="level1"><a href="#usage">Library Organisation</a></li>
<li class="level1"><a href="#function_usage">The DiscreteFunction Class</a><ul><li class="level2"><a href="#function_construction">Construction</a></li>
<li class="level2"><a href="#function_access">Element Access</a></li>
<li class="level2"><a href="#math_ops">Mathematical Operations</a><ul><li class="level3"><a href="#scalar_ops">Scalar Operations</a></li>
<li class="level3"><a href="#domain_ops">Domain Operations</a></li>
<li class="level3"><a href="#arithmetic_ops">Arithmetic Operations</a></li>
</ul>
</li>
<li class="level2"><a href="#comparision_ops">Comparison Operations</a></li>
<li class="level2"><a href="#misc_ops">Miscellaneous Operations</a></li>
</ul>
</li>
<li class="level1"><a href="#domainIterator">The DomainIterator Class</a></li>
<li class="level1"><a href="#maxsumcontroller">The MaxSumController Class</a></li>
<li class="level1"><a href="#tips">Tips on Writing Efficient Code</a></li>
<li class="level1"><a href="#futurework">Future Work</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Overview</h1>
<p>This library provides an implementation of the max-sum algorithm in C++. For more details about the purpose and theory behind this algorithm, please see <a href="http://eprints.soton.ac.uk/265159/">http://eprints.soton.ac.uk/265159/</a></p>
<p>To source code for this library can be dowloaded from <a href="https://github.com/lteacy/maxsum-cpp">here</a>.</p>
<h1><a class="anchor" id="usage"></a>
Library Organisation</h1>
<p>The contents of this library are organised into two main namespaces: </p>
<ul>
<li><a class="el" href="namespacemaxsum.html" title="Namespace for all public types and functions defined by the Max-Sum library.">maxsum</a>, which contains all functions and classes that form part the public iterface to this library; and </li>
<li><a class="el" href="namespacemaxsum_1_1util.html" title="Utility namespace for types used for maxsum library implementation.">maxsum::util</a>, which contains utility code that forms part of the library implementation.</li>
</ul>
<p>Our intention here is that only functions and types that are of direct interest to third party developers should be located in the <a class="el" href="namespacemaxsum.html" title="Namespace for all public types and functions defined by the Max-Sum library.">maxsum</a> namespace. In contrast, those in the <a class="el" href="namespacemaxsum_1_1util.html" title="Utility namespace for types used for maxsum library implementation.">maxsum::util</a> interface are not intended to form part of the public interface to the library, and so should only be of interest to developers intended to extend or modify this library.</p>
<p>Of the classes in the maxsum namespace, three provide the bulk of the library's functionality, and should be of particular interest to anyone wishing to apply the max-sum algorithm: </p>
<ul>
<li><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a>, which is used to represent mathematical functions that depend on the cartesian product of a set of variables with finite domains; </li>
<li><a class="el" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of variable domains...">maxsum::DomainIterator</a>, which provides methods for iterating over the domain of <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> objects; and </li>
<li><a class="el" href="classmaxsum_1_1_max_sum_controller.html" title="This class maintains a factor graph and implements the max-sum algorithm.">maxsum::MaxSumController</a>, which operates on a <em>factor</em> <em>graph</em>, to optimise the values assigned to a set of (action) variables.</li>
</ul>
<p>The following sections describe each of these classes in more detail, together with example extracts of code to demonstrate their proper use.</p>
<h1><a class="anchor" id="function_usage"></a>
The DiscreteFunction Class</h1>
<p>The <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> class is the main workhorse of the maxsum library, which not only provides a way to represent mathematical functions, but also to manipulate their values, and combine them using various mathematical operators to form new functions. As the class name suggests, the main limitation is that only functions with a finite domain can be represented, values of which are stored internally for each possible value of a function's domain.</p>
<p>In future versions, we may provide other classes which can be used to represent functions with continuous domains. However, for now, the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> class provides all the operations necessary to apply the max-sum algorithm to finite domains. In particular, the following subsections describe the main operations that can be performed using this class.</p>
<h2><a class="anchor" id="function_construction"></a>
Construction</h2>
<p>The domain of each <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> is specified by a set of variables, identified by ids of type <a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a>. Each variables, <code>k</code>, is associated with a fixed domain size, <img class="formulaInl" alt="$N_k$" src="form_3.png"/>, which must be registered before the variable is used, and must remain the same through a program's execution. Once registered, a variable can then take on any integer value in the range <img class="formulaInl" alt="$[0,N_k]$" src="form_4.png"/>. For example, to create a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> that depends on a single variable, <code>2</code>, we may execute the following code: </p>
<pre>
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">maxsum::registerVariable</a> (2, 10);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(2,3.2);
</pre><p> Here, variable <code>2</code> is registered with domain size <code>10</code>, which means that it can take on values in the range <img class="formulaInl" alt="$[0,9]$" src="form_5.png"/>. The 2nd parameter of this constructor is used to initialise all values for this function to a specific value, in this case 3.2. So, for example, we have </p>
<pre>
num = func.noVars(); // num == 1 (depends on one variable only)
siz = func.domainSize(); // siz == 10
val = func(0);  // val == 3.2
...
val = func(9);  // val == 3.2
val = func(10); // result undefined!!
</pre><p> In addition to depending on a single value, <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s can also depend on multiple variables, or the empty set. In the latter, case the function encapsulates a single scalar constant, which does not depend on any variable, and is index by 0: </p>
<pre>
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(4.5); // depends on no variables
num = func.noVars();     // num==0 (depends on no variables)
siz = func.domainSize(); // siz==1 (has only one value)
val = func(0); // val == 4.5
val = func(1); // result undefined!!
</pre><p> For the former case, there are several options for defining functions that depend on several variables. In particular, we can achieve this by passing a list of variable ids to the constructor using iterators. For example: </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> vars[] = {1,4,8}; // array of size 3
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> siz[] = {5,10,15}; // var 1 has domain size 5 etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">maxsum::registerVariables</a> (vars,vars+3,siz,size+3);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(vars,vars+3); // values initialised to 0
num = func.noVars(); // num=3 (depends on three variables)
siz = func.domainSize(); // siz=5*10*15 (size of cartesian product)
val = func(0);   // val == 0
val = func(749); // val == 0 (see below for full explanation)
val = func(750); // result undefined!!
</pre><p> In addition to these, other constructors include a copy constructor and matching assignment operator; and a default constructor, which creates a function that depends on no variables and has a single value of 0. For details, see the manual page for <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>.</p>
<h2><a class="anchor" id="function_access"></a>
Element Access</h2>
<p>As demonstrated in the examples above, the basic and most efficient way to access the values of a function, is to pass a single integer value to the overloaded () operator. This single integer value acts like a linear index for N-D arrays in matlab, except that values start from 0 rather than 1. Moreover, all versions of the () operator return references to values in a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>, and so can be used for setting as well as reading values. For example, the following code is valid. </p>
<pre>
func(1) = 3.45; // set func(1) to 3.45
val = func(1);  // val == 3.45
</pre><p>As in matlab, or indeed any scheme for indexing N-D arrays, these linear indices depend on the order in which each dimension is stored in memory. In our case, each variable in a function's domain corresponds to a dimension in an N-D array, with variables ordered from least to most significant according to their ID. For example, if <code>func</code> depends on variables 3 and 5 with corresponding domain sizes 2 and 3, then we have the following correspondence between variable values and linear indices: </p>
<table class="doxtable">
<tr>
<th>Variable 3</th><th>Variable 5</th><th>Linear Index </th></tr>
<tr>
<td>0</td><td>0</td><td>0 </td></tr>
<tr>
<td>1</td><td>0</td><td>1 </td></tr>
<tr>
<td>0</td><td>1</td><td>2 </td></tr>
<tr>
<td>1</td><td>1</td><td>3 </td></tr>
<tr>
<td>0</td><td>2</td><td>4 </td></tr>
<tr>
<td>1</td><td>2</td><td>5 </td></tr>
</table>
<p>Here, notice how variable 3, having the smalled variable id, is incremented first, before the variable with the next largest id, which is 5. The situation is the same for variables with more than two variables: the variable with the smallest id is incremented first, and so on until the variable with the highest id, which is incremented last.</p>
<p>Although the most efficient way to access elements using linear indices, these are often not available, and so must be calculated from a set of subindices, relating to named variables. For this reason, several other versions of the () operator are available that except subindices. For example, if variable names and values are stored in lists, s.t. the kth index gives the value for the kth variable, then we can access elements as follows. </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> vars[] = {1,4,8}; // array of size 3
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> siz[] = {5,10,15}; // var 1 has domain size 5 etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">maxsum::registerVariables</a> (vars,vars+3,siz,size+3);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(vars,vars+3); // values initialised to 0</pre><pre>std::vector&lt;VarID&gt; varVec(vars,vars+3); // copy ids into vector
std::vector&lt;ValIndex&gt; valVec(3); // vector of size 3
valVec[0] = 2; // index value for variable 1
valVec[1] = 4; // index value for variable 4
valVec[2] = 5; // index value for variable 8</pre><pre> // THE FOLLOWING STATEMENTS ALL ACCESS THE SAME ELEMENT
int linearIndex = 2+4*10+5*15*10; // corresponding linear index
func(2,4,5); // specify indices in order of variable id
func(valVec.begin(),valVec.end()); // indices in order of variable id
func(linearIndex); // access by corresponding linear index
func(varVec,valVec); // access by named variables in lists (does not work for arrays)
func(vars,vars+3,valVec.begin(),valVec.end()); // access by named variables using iterators
func(varVec.begin(),varVec.end(),valVec.begin(),valVec.end()); 
</pre><p> Here, the last three variants all work by specifying named variables and corresponding values in lists, either by passing reference to containers directly (which must supply interfaces consistent with standard library containers), or by passing iterators to such lists. In each case, the kth value is assumed to correspond to the kth named variable. Any values specified for variables that are not in the functions domain are ignored.</p>
<p>For some versions of the () operator, the member function <a class="el" href="classmaxsum_1_1_discrete_function.html#a7cc147d43c4e523d54a0601150e1954b" title="Access coefficient using scalar index.">maxsum::DiscreteFunction::at</a> is also provided for convenient element access through pointers. For example, the following code is valid: </p>
<pre>
using namespace <a class="el" href="namespacemaxsum.html" title="Namespace for all public types and functions defined by the Max-Sum library.">maxsum</a>;
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">registerVariable</a> (3,5);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> func(3,4.5);
DiscreteFunction* pFunc = &amp;func;
val = (*pFunc)(2);  // works, but ugly
val = pFunc-&gt;at(2); // equivalent, but more readable
</pre><h2><a class="anchor" id="math_ops"></a>
Mathematical Operations</h2>
<p>Three main types of mathematical operation are provided by the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> class, each of which are described below. </p>
<h3><a class="anchor" id="scalar_ops"></a>
Scalar Operations</h3>
<p><em>Scalar</em> operations are used to calculate specific statistics about a function's values over its domain. The table below summarises the available scalar operations, together with their mathematical definition w.r.t. a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a>, <img class="formulaInl" alt="$f$" src="form_6.png"/>, with linear indices 1 to <code>N</code>. </p>
<table class="doxtable">
<tr>
<th>Member Function</th><th>Definition </th></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#af23096f6b1f8460b5899367ca5cf16ce" title="Returns the mean scalar value for function across entire domain.">DiscreteFunction::mean</a></td><td><img class="formulaInl" alt="$\frac{1}{N} \sum_{k=1}^N f(k)$" src="form_7.png"/> </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a8808e251912f0bb3ad768948b754a3f4" title="Returns the maximum scalar value for function across entire domain.">DiscreteFunction::max</a></td><td><img class="formulaInl" alt="$\max_k f(k)$" src="form_8.png"/> </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#ab1391246a7b2b192fdab3400d2e36407" title="Returns the minimum scalar value of the function across entire domain.">DiscreteFunction::min</a></td><td><img class="formulaInl" alt="$\min_k f(k)$" src="form_9.png"/> </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a949b94c6527b4115a92357adc249a3a8" title="Returns the maxnorm for this function.">DiscreteFunction::maxnorm</a></td><td><img class="formulaInl" alt="$\max_k |f(k)|$" src="form_10.png"/> </td></tr>
</table>
<h3><a class="anchor" id="domain_ops"></a>
Domain Operations</h3>
<p><em>Domain</em> operations operate on a single <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> object to reduce or expand its domain in some way. In particular, the <a class="el" href="classmaxsum_1_1_discrete_function.html#a6490769ee942e61ea54dd91cc6f7ff25" title="Make this function depend on additional variables.">DiscreteFunction::expand</a> member extends the set of variables that a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> depends on, such that its new domain is the union of its previous domain, and a set of variables specified by the expand function's arguments. Several overloaded versions exist that allow the new set of variables to be specified in different ways: </p>
<table class="doxtable">
<tr>
<th>Member Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a8497dfc35f67d66cbca3c6f072ff188f" title="Expand the domain of this function to include a named variable.">DiscreteFunction::expand(const VarID var)</a> </td><td>Expands the domain to include the variable <code>var</code>. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#ad1b43bd614257887b4084ee2de1e721b" title="Make the domain of this function include the domain of another.">DiscreteFunction::expand(const DiscreteFunction&amp; fun)</a> </td><td>Expands the domain of <code>this</code> <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> to include all variables in the domain of <code>fun</code>. </td></tr>
<tr>
<td>template&lt;class VarInd&gt; <a class="el" href="classmaxsum_1_1_discrete_function.html#a6490769ee942e61ea54dd91cc6f7ff25" title="Make this function depend on additional variables.">DiscreteFunction::expand(VarInd begin,VarInd end)</a> </td><td>Expands the domain to include all variables in the sequence pointed to by the iterators <code>begin</code> and <code>end</code>. </td></tr>
</table>
<p>After a call to <code>expand</code>, the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s values remain the same for all elements of its previous domain. For example </p>
<pre>
using namespace maxsum;
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">registerVariable</a> (1,3);
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">registerVariable</a> (2,3);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> func(2,0); // depends only on variable 2
func(0) = 1.1;
func(1) = 2.2;
func(2) = 3.3;</pre><pre>func.expand(1);   // func now depends on variables 1 and 2
val = func(1,0);  // val == 1.1
val = func(2,0);  // val == 1.1
val = func(1,2);  // val == 3.3
val = func(2,2);  // val == 3.3
</pre><p> As well as expanding a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain, it is often necessary to <em>reduce</em> its domain. In general, this results in a loss of information, so it is necessary to specify how the values in the new smaller domain are derived from those in the original larger domain. Currently, there are two ways to do this.</p>
<p>First, the <a class="el" href="classmaxsum_1_1_discrete_function.html#ae0bc8ada042a00e5cd917d8af8dfd0e8" title="Condition function on specified variable values.">DiscreteFunction::condition</a> member function can be used to specify fixed values for a set of variables that are to be removed from a function's domain. For example, following on from the code in the last example, we may may reduce the domain of <code>func</code> as follows. </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">VarID</a> toRemove[] = {2}; // list of variables to remove
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> vals[] = {1};   // fixed values for removed variables
func.condition (toRemove,toRemove+1,vals,vals+1); // specify iterators over arrays</pre><pre>val = func(0); // val == 2.2 (because variable 2 was given fixed value 1)
val = func(1); // val == 2.2 (see code above)
val = func(2); // val == 2.2
</pre><p>Second, rather than conditioning on specific values for the removed removed variables, we can <em>marginalise</em> by somehow aggregating all the values for the removed variables to produce a single value. In particular, the definition of the max-sum algorithm requires variables to be removed by taking a function's maximum value across the removed variables. Here, this is achieved using the <a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> function, which takes the maximum value of one <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> across a set variables, and stores the result in another <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>.</p>
<p>This works by passing references to two DiscreteFunctions: the first, <code>inFun</code>, is the original function to be marginalised, and the second, <code>outFun</code>, is a function with a smaller domain, in which the result will be stored. The domain of <code>outFun</code> must not be larger than the domain of <code>inFun</code>, and any variables that are in the domain of <code>inFun</code>, but not in the domain of <code>outFun</code>, will be marginalised. This procedure is demonstrated in the following code. </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">VarID</a> vars = {1,2};
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> siz = {2,3}; // variable 1 has domain size 2, etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">registerVariables</a> (vars,vars+2,siz,siz+2);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> inFun(vars,vars+2);  // depends on variables 1 and 2
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> outFun(vars,vars+1); // depends on variable 1 only</pre><pre>inFun(0,0) = 1; // assign some values to inFun
inFun(1,1) = 2;
inFun(0,2) = 3;
inFun(1,0) = 4;
inFun(0,1) = 5;
inFun(1,2) = 6;</pre><pre><a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> (inFun,outFun); // max marginalise inFun and store result in outFun</pre><pre>val = outFun(0);  // val==5 (maximum value for variable 1=0 in inFun)
val = outFun(1);  // val==6 (maximum value for variable 1=1 in inFun)
</pre><p> The reason for this style is efficiency: by preallocating <code>outFun</code> to store the result, we do not need to not need to allocate temporary objects in memory, and if necessary, can reuse <code>outFun</code> to store the result of several similar marginalisations.</p>
<p>More generally, the maxsum library also provides a number marginalisation functions, which aggregate across the removed variables in different ways. These are summarised in the table below. However, only the <a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> function is actually required to implement the max-sum algorithm. See <a href="#maxsumcontroller">The MaxSumController Class</a> for details. </p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> </td><td>Marginalise by maximising across removed variables. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">minMarginal</a> </td><td>Marginalise by minimising across removed variables. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">meanMarginal</a> </td><td>Marginalise by averaging across removed variables. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#ae48b4828eefae581abf6b475b8d8f60c" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">marginal</a> </td><td>Marginalise using a custom aggregation function. </td></tr>
</table>
<h3><a class="anchor" id="arithmetic_ops"></a>
Arithmetic Operations</h3>
<p>Arithmetric operations on <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s are provided by overloading the standardard arithmetric operators in C++, including <code>+</code>, <code>-</code>, and <code>*</code>. These operations are applied elementwise across the cartesian product of the operands' domains, as illustrated in the following example: </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">VarID</a> vars = {1,2};
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> siz = {2,3}; // variable 1 has domain size 2, etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">registerVariables</a> (vars,vars+2,siz,siz+2);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> f(vars,vars+1);   // depends only on variable 1
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> g(vars+1,vars+2); // depends only on variable 2
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> h(vars,vars+2);   // depends on variables 1 and 2</pre><pre>// assign some values
  f(0) = 1.0;   f(1) = 1.1;
  g(0) = 2.0;   g(1) = 2.1;   g(2) = 2.2;
h(0,0) = 3.0; h(0,1) = 3.1; h(0,2) = 3.2;
h(1,0) = 4.0; h(1,1) = 4.1; h(1,2) = 4.2;</pre><pre><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> x = f+g;
// x(0,0) == f(0) + g(0) == 1.0 + 2.0 == 3.0;
// x(1,0) == f(1) + g(0) == 1.1 + 2.0 == 3.1;
// ....
// x(1,2) == f(1) + g(2) == 1.1 + 2.2 == 3.3;</pre><pre><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> y = f+h;
// y(0,0) == f(0) + h(0,0) == 1.0 + 3.0 == 4.0;
// y(1,0) == f(1) + h(1,0) == 1.1 + 4.0 == 5.1;
// ....
// y(1,2) == f(1) + h(1,2) == 1.1 + 4.2 == 5.3;
</pre><p> Here, notice that the domain of the results, <code>x</code> and <code>y</code>, are automatically set to the cartesian product of the domains of the operands. The following operations are all similarly defined. </p>
<table class="doxtable">
<tr>
<th>Operation</th><th>Description </th></tr>
<tr>
<td><code>f + g</code></td><td>Element-wise addition. </td></tr>
<tr>
<td><code>f - g</code></td><td>Element-wise subtraction. </td></tr>
<tr>
<td><code>f * g</code></td><td>Element-wise multiplication. </td></tr>
<tr>
<td><code>f += g</code></td><td>Element-wise addition, storing result in <code>f</code>. </td></tr>
<tr>
<td><code>f -= g</code></td><td>Element-wise subtraction, storing result in <code>f</code>. </td></tr>
<tr>
<td><code>f *= g</code></td><td>Element-wise multiplication, storing result in <code>f</code>. </td></tr>
<tr>
<td><code> -g</code></td><td>Unary Minus. </td></tr>
</table>
<h2><a class="anchor" id="comparision_ops"></a>
Comparison Operations</h2>
<p>Equality between DiscreteFunctions can be defined in several ways, and for this reason the maxsum library provides three different functions for testing equality between <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> objects: </p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a15f2209735d087f5f25c68f9cb1778b0" title="Check that two maxsum::DiscreteFunction objects have the same domain.">sameDomain(const DiscreteFunction&amp; f1, const DiscreteFunction&amp; f2)</a></td><td>Returns true iff <code>f1</code> and <code>f2</code> have the same domain. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a6386d78723ee3d5d0202f05c2a3c7726" title="Check that two maxsum::DiscreteFunction objects are equal within a specified tolerance.">equalWithinTolerance(const DiscreteFunction&amp; f1, const DiscreteFunction&amp; f2, ValType tol)</a> </td><td>Returns true iff <code>f1</code> and <code>f2</code> are equal across the cartesian product of their domains, within a given tolerance, <code>tol</code>. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a0e6948dba163b8d6a51a41f2ea24a182" title="Check that two maxsum::DiscreteFunction objects are equal with a specified tolerance, and have exactly the same domain.">strictlyEqualWithinTolerance(const DiscreteFunction&amp; f1, const DiscreteFunction&amp; f2, ValType tol)</a> </td><td>Returns true iff <code>sameDomain(f1,f2) &amp;&amp; equalWithinTolerance(f1,f2,tol)</code> </td></tr>
</table>
<p>The functions <a class="el" href="namespacemaxsum.html#a6386d78723ee3d5d0202f05c2a3c7726" title="Check that two maxsum::DiscreteFunction objects are equal within a specified tolerance.">equalWithinTolerance</a> and <a class="el" href="namespacemaxsum.html#a0e6948dba163b8d6a51a41f2ea24a182" title="Check that two maxsum::DiscreteFunction objects are equal with a specified tolerance, and have exactly the same domain.">strictlyEqualWithinTolerance</a> are provided so that two DiscreteFunctions can be treated as equal in cases where their values differ only by some small rounding error. For cases in which strict equality is required between values is required (i.e. the error tolerance is 0), the standard equality and inequality operators may also be used: </p>
<table class="doxtable">
<tr>
<th>Operator</th><th>Definition </th></tr>
<tr>
<td><code>f1==f2</code></td><td><code>equalWithinTolerance(f1,f2,0)</code> </td></tr>
<tr>
<td><code>f1!=f2</code></td><td><code>!equalWithinTolerance(f1,f2,0)</code> </td></tr>
</table>
<h2><a class="anchor" id="misc_ops"></a>
Miscellaneous Operations</h2>
<h1><a class="anchor" id="domainIterator"></a>
The DomainIterator Class</h1>
<p>Todo.</p>
<h1><a class="anchor" id="maxsumcontroller"></a>
The MaxSumController Class</h1>
<p>Todo.</p>
<h1><a class="anchor" id="tips"></a>
Tips on Writing Efficient Code</h1>
<p>Todo.</p>
<h1><a class="anchor" id="futurework"></a>
Future Work</h1>
<p>Although the basic implementation of this library is now complete, this project is still under going its first phase of active development. Accurate results are thus not yet guarranteed, and in fact, bugs are very much still to be expected.</p>
<p>For now, our main priority is thus continued testing and debugging. Beyond that, we also plan to look at various options for optimising the code. For example, one option is to link to the <a href="http://eigen.tuxfamily.org">eigen3</a> linear algebra library, to take advantage of its hardware vectorisation.</p>
<p>We will also continue to improve this documentation of the API. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 2 2012 14:50:46 for Max-Sum by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
