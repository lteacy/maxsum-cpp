<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Max-Sum: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Max-Sum
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Max-Sum Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Overview</a></li>
<li class="level1"><a href="#usage">Library Organisation</a></li>
<li class="level1"><a href="#function_usage">The DiscreteFunction Class</a><ul><li class="level2"><a href="#function_construction">Construction</a></li>
<li class="level2"><a href="#function_access">Element Access</a></li>
<li class="level2"><a href="#math_ops">Mathematical Operations</a><ul><li class="level3"><a href="#scalar_ops">Scalar Operations</a></li>
<li class="level3"><a href="#domain_ops">Domain Operations</a></li>
<li class="level3"><a href="#arithmetic_ops">Arithmetic Operations</a></li>
</ul>
</li>
<li class="level2"><a href="#comparision_ops">Comparison Operations</a></li>
<li class="level2"><a href="#misc_ops">Miscellaneous Operations</a></li>
</ul>
</li>
<li class="level1"><a href="#domainIterator">The DomainIterator Class</a></li>
<li class="level1"><a href="#maxsumcontroller">The MaxSumController Class</a></li>
<li class="level1"><a href="#tips">Tips on Writing Efficient Code</a></li>
<li class="level1"><a href="#futurework">Future Work</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Overview</h1>
<p>This library provides an implementation of the max-sum algorithm in C++. For more details about the purpose and theory behind this algorithm, please see <a href="http://eprints.soton.ac.uk/265159/">http://eprints.soton.ac.uk/265159/</a></p>
<p>The source code for this library can be dowloaded from <a href="https://github.com/lteacy/maxsum-cpp">here</a>.</p>
<p>A pdf version of this documentation is also available <a href="maxsum_api.pdf">here</a>.</p>
<p>If you have any comments or suggestions about this library or its documentation, please let me know via the main <a href="https://github.com/lteacy/maxsum-cpp">project website</a>.</p>
<h1><a class="anchor" id="usage"></a>
Library Organisation</h1>
<p>The contents of this library are organised into two namespaces: </p>
<ul>
<li><a class="el" href="namespacemaxsum.html" title="Namespace for all public types and functions defined by the Max-Sum library.">maxsum</a>, which contains all functions and classes that form part the public interface to this library; and </li>
<li><a class="el" href="namespacemaxsum_1_1util.html" title="Utility namespace for types used for maxsum library implementation.">maxsum::util</a>, which contains utility code that forms part of the library implementation.</li>
</ul>
<p>Our intention here is that only functions and types that are of direct interest to third party developers should be located in the <a class="el" href="namespacemaxsum.html" title="Namespace for all public types and functions defined by the Max-Sum library.">maxsum</a> namespace. In contrast, those in the <a class="el" href="namespacemaxsum_1_1util.html" title="Utility namespace for types used for maxsum library implementation.">maxsum::util</a> interface are not intended to form part of the public interface to the library, and so should only be of interest to developers who wish to extend or modify the library.</p>
<p>Of the classes in the maxsum namespace, three provide the bulk of the library's functionality, and should be of particular interest to anyone wishing to apply the max-sum algorithm: </p>
<ul>
<li><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a>, which is used to represent mathematical functions that depend on the cartesian product of a set of variables with finite domains; </li>
<li><a class="el" href="classmaxsum_1_1_domain_iterator.html" title="This class provides methods for iterating over the Cartesian product for a set of variable domains...">maxsum::DomainIterator</a>, which provides methods for iterating over the domain of <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> objects; and </li>
<li><a class="el" href="classmaxsum_1_1_max_sum_controller.html" title="This class maintains a factor graph and implements the max-sum algorithm.">maxsum::MaxSumController</a>, which operates on a <em>factor</em> <em>graph</em>, to optimise the values assigned to a set of (action) variables.</li>
</ul>
<p>The following sections describe each of these classes in more detail, together with example extracts of code to demonstrate their proper use.</p>
<h1><a class="anchor" id="function_usage"></a>
The DiscreteFunction Class</h1>
<p>The <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> class is the main workhorse of the maxsum library, which not only provides a way to represent mathematical functions, but also to manipulate their values, and combine them using various mathematical operators to form new functions. As the class name suggests, the main limitation is that only functions with a finite domain can be represented, values of which are stored internally for each possible value of a function's domain.</p>
<p>In future versions, we may provide other classes which can be used to represent functions with continuous domains. However, for now, the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> class provides all the operations necessary to apply the max-sum algorithm to finite domains. In particular, the following subsections describe the main operations that can be performed using this class.</p>
<h2><a class="anchor" id="function_construction"></a>
Construction</h2>
<p>The domain of each <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> is specified by a set of variables, identified by ids of type <a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a>. Each variables, <code>k</code>, is associated with a fixed domain size, <img class="formulaInl" alt="$N_k$" src="form_3.png"/>, which must be registered before the variable is used, and must remain the same through a program's execution. Once registered, a variable can then take on any integer value in the range <img class="formulaInl" alt="$[0,N_k]$" src="form_4.png"/>. For example, to create a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> that depends on a single variable, <code>2</code>, we may execute the following code: </p>
<pre>
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">maxsum::registerVariable</a> (2, 10);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(2,3.2);
</pre><p> Here, variable <code>2</code> is registered with domain size <code>10</code>, which means that it can take on values in the range <img class="formulaInl" alt="$[0,9]$" src="form_5.png"/>. The 2nd parameter of this constructor is used to initialise all values for this function to a specific value, in this case 3.2. So, for example, we have </p>
<pre>
num = func.noVars(); // num == 1 (depends on one variable only)
siz = func.domainSize(); // siz == 10
val = func(0);  // val == 3.2
...
val = func(9);  // val == 3.2
val = func(10); // result undefined!!
</pre><p> In addition to depending on a single value, <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s can also depend on multiple variables, or the empty set. In the latter, case the function encapsulates a single scalar constant, which does not depend on any variable, and is index by 0: </p>
<pre>
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(4.5); // depends on no variables
num = func.noVars();     // num==0 (depends on no variables)
siz = func.domainSize(); // siz==1 (has only one value)
val = func(0); // val == 4.5
val = func(1); // result undefined!!
</pre><p> For the former case, there are several options for defining functions that depend on several variables. In particular, we can achieve this by passing a list of variable ids to the constructor using iterators. For example: </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> vars[] = {1,4,8}; // array of size 3
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> siz[] = {5,10,15}; // var 1 has domain size 5 etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">maxsum::registerVariables</a> (vars,vars+3,siz,size+3);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(vars,vars+3); // values initialised to 0
num = func.noVars(); // num=3 (depends on three variables)
siz = func.domainSize(); // siz=5*10*15 (size of cartesian product)
val = func(0);   // val == 0
val = func(749); // val == 0 (see below for full explanation)
val = func(750); // result undefined!!
</pre><p> In addition to these, other constructors include a copy constructor and matching assignment operator; and a default constructor, which creates a function that depends on no variables and has a single value of 0. For details, see the manual page for <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>.</p>
<h2><a class="anchor" id="function_access"></a>
Element Access</h2>
<p>As demonstrated in the examples above, the basic and most efficient way to access the values of a function, is to pass a single integer value to the overloaded () operator. This single integer value acts like a linear index for N-D arrays in matlab, except that values start from 0 rather than 1. Moreover, all versions of the () operator return references to values in a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>, and so can be used for setting as well as reading values. For example, the following code is valid. </p>
<pre>
func(1) = 3.45; // set func(1) to 3.45
val = func(1);  // val == 3.45
</pre><p>As in matlab, or indeed any scheme for indexing N-D arrays, these linear indices depend on the order in which each dimension is stored in memory. In our case, each variable in a function's domain corresponds to a dimension in an N-D array, with variables ordered from least to most significant according to their ID. For example, if <code>func</code> depends on variables 3 and 5 with corresponding domain sizes 2 and 3, then we have the following correspondence between variable values and linear indices: </p>
<table class="doxtable">
<tr>
<th>Variable 3</th><th>Variable 5</th><th>Linear Index </th></tr>
<tr>
<td>0</td><td>0</td><td>0 </td></tr>
<tr>
<td>1</td><td>0</td><td>1 </td></tr>
<tr>
<td>0</td><td>1</td><td>2 </td></tr>
<tr>
<td>1</td><td>1</td><td>3 </td></tr>
<tr>
<td>0</td><td>2</td><td>4 </td></tr>
<tr>
<td>1</td><td>2</td><td>5 </td></tr>
</table>
<p>Here, notice how variable 3, having the smalled variable id, is incremented first, before the variable with the next largest id, which is 5. The situation is the same for variables with more than two variables: the variable with the smallest id is incremented first, and so on until the variable with the highest id, which is incremented last.</p>
<p>Although the most efficient way to access elements using linear indices, these are often not available, and so must be calculated from a set of subindices, relating to named variables. For this reason, several other versions of the () operator are available that except subindices. For example, if variable names and values are stored in lists, s.t. the kth index gives the value for the kth variable, then we can access elements as follows. </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">maxsum::VarID</a> vars[] = {1,4,8}; // array of size 3
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">maxsum::ValIndex</a> siz[] = {5,10,15}; // var 1 has domain size 5 etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">maxsum::registerVariables</a> (vars,vars+3,siz,size+3);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> func(vars,vars+3); // values initialised to 0</pre><pre>std::vector&lt;VarID&gt; varVec(vars,vars+3); // copy ids into vector
std::vector&lt;ValIndex&gt; valVec(3); // vector of size 3
valVec[0] = 2; // index value for variable 1
valVec[1] = 4; // index value for variable 4
valVec[2] = 5; // index value for variable 8</pre><pre> // THE FOLLOWING STATEMENTS ALL ACCESS THE SAME ELEMENT
int linearIndex = 2+4*10+5*15*10; // corresponding linear index
func(2,4,5); // specify indices in order of variable id
func(valVec.begin(),valVec.end()); // indices in order of variable id
func(linearIndex); // access by corresponding linear index
func(varVec,valVec); // access by named variables in lists (does not work for arrays)
func(vars,vars+3,valVec.begin(),valVec.end()); // access by named variables using iterators
func(varVec.begin(),varVec.end(),valVec.begin(),valVec.end()); 
</pre><p> Here, the last three variants all work by specifying named variables and corresponding values in lists, either by passing reference to containers directly (which must supply interfaces consistent with standard library containers), or by passing iterators to such lists. In each case, the kth value is assumed to correspond to the kth named variable. Any values specified for variables that are not in the functions domain are ignored.</p>
<p>For some versions of the () operator, the member function <a class="el" href="classmaxsum_1_1_discrete_function.html#a7cc147d43c4e523d54a0601150e1954b" title="Access coefficient using scalar index.">maxsum::DiscreteFunction::at</a> is also provided for convenient element access through pointers. For example, the following code is valid: </p>
<pre>
using namespace <a class="el" href="namespacemaxsum.html" title="Namespace for all public types and functions defined by the Max-Sum library.">maxsum</a>;
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">registerVariable</a> (3,5);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> func(3,4.5);
DiscreteFunction* pFunc = &amp;func;
val = (*pFunc)(2);  // works, but ugly
val = pFunc-&gt;at(2); // equivalent, but more readable
</pre><h2><a class="anchor" id="math_ops"></a>
Mathematical Operations</h2>
<p>Three main types of mathematical operation are provided by the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a> class, each of which are described below. </p>
<h3><a class="anchor" id="scalar_ops"></a>
Scalar Operations</h3>
<p><em>Scalar</em> operations are used to calculate specific statistics about a function's values over its domain. The table below summarises the available scalar operations, together with their mathematical definition w.r.t. a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">maxsum::DiscreteFunction</a>, <img class="formulaInl" alt="$f$" src="form_6.png"/>, with linear indices 1 to <code>N</code>. </p>
<table class="doxtable">
<tr>
<th>Member Function</th><th>Definition </th></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#af23096f6b1f8460b5899367ca5cf16ce" title="Returns the mean scalar value for function across entire domain.">DiscreteFunction::mean</a></td><td><img class="formulaInl" alt="$\frac{1}{N} \sum_{k=1}^N f(k)$" src="form_7.png"/> </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a8808e251912f0bb3ad768948b754a3f4" title="Returns the maximum scalar value for function across entire domain.">DiscreteFunction::max</a></td><td><img class="formulaInl" alt="$\max_k f(k)$" src="form_8.png"/> </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#ab1391246a7b2b192fdab3400d2e36407" title="Returns the minimum scalar value of the function across entire domain.">DiscreteFunction::min</a></td><td><img class="formulaInl" alt="$\min_k f(k)$" src="form_9.png"/> </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a949b94c6527b4115a92357adc249a3a8" title="Returns the maxnorm for this function.">DiscreteFunction::maxnorm</a></td><td><img class="formulaInl" alt="$\max_k |f(k)|$" src="form_10.png"/> </td></tr>
</table>
<h3><a class="anchor" id="domain_ops"></a>
Domain Operations</h3>
<p><em>Domain</em> operations operate on a single <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> object to reduce or expand its domain in some way. In particular, the <a class="el" href="classmaxsum_1_1_discrete_function.html#a6490769ee942e61ea54dd91cc6f7ff25" title="Make this function depend on additional variables.">DiscreteFunction::expand</a> member extends the set of variables that a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> depends on, such that its new domain is the union of its previous domain, and a set of variables specified by the expand function's arguments. Several overloaded versions exist that allow the new set of variables to be specified in different ways: </p>
<table class="doxtable">
<tr>
<th>Member Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a8497dfc35f67d66cbca3c6f072ff188f" title="Expand the domain of this function to include a named variable.">DiscreteFunction::expand(const VarID var)</a> </td><td>Expands the domain to include the variable <code>var</code>. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#ad1b43bd614257887b4084ee2de1e721b" title="Make the domain of this function include the domain of another.">DiscreteFunction::expand(const DiscreteFunction&amp; fun)</a> </td><td>Expands the domain of <code>this</code> <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> to include all variables in the domain of <code>fun</code>. </td></tr>
<tr>
<td>template&lt;class VarInd&gt; <a class="el" href="classmaxsum_1_1_discrete_function.html#a6490769ee942e61ea54dd91cc6f7ff25" title="Make this function depend on additional variables.">DiscreteFunction::expand(VarInd begin,VarInd end)</a> </td><td>Expands the domain to include all variables in the sequence pointed to by the iterators <code>begin</code> and <code>end</code>. </td></tr>
</table>
<p>After a call to <code>expand</code>, the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s values remain the same for all elements of its previous domain. For example </p>
<pre>
using namespace maxsum;
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">registerVariable</a> (1,3);
<a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">registerVariable</a> (2,3);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> func(2,0); // depends only on variable 2
func(0) = 1.1;
func(1) = 2.2;
func(2) = 3.3;</pre><pre>func.expand(1);   // func now depends on variables 1 and 2
val = func(1,0);  // val == 1.1
val = func(2,0);  // val == 1.1
val = func(1,2);  // val == 3.3
val = func(2,2);  // val == 3.3
</pre><p> As well as expanding a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain, it is often necessary to <em>reduce</em> its domain. In general, this results in a loss of information, so it is necessary to specify how the values in the new smaller domain are derived from those in the original larger domain. Currently, there are two ways to do this.</p>
<p>First, the <a class="el" href="classmaxsum_1_1_discrete_function.html#ae0bc8ada042a00e5cd917d8af8dfd0e8" title="Condition function on specified variable values.">DiscreteFunction::condition</a> member function can be used to specify fixed values for a set of variables that are to be removed from a function's domain. For example, following on from the code in the last example, we may may reduce the domain of <code>func</code> as follows. </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">VarID</a> toRemove[] = {2}; // list of variables to remove
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> vals[] = {1};   // fixed values for removed variables
func.condition (toRemove,toRemove+1,vals,vals+1); // specify iterators over arrays</pre><pre>val = func(0); // val == 2.2 (because variable 2 was given fixed value 1)
val = func(1); // val == 2.2 (see code above)
val = func(2); // val == 2.2
</pre><p>Second, rather than conditioning on specific values for the removed removed variables, we can <em>marginalise</em> by somehow aggregating all the values for the removed variables to produce a single value. In particular, the definition of the max-sum algorithm requires variables to be removed by taking a function's maximum value across the removed variables. Here, this is achieved using the <a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> function, which takes the maximum value of one <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> across a set variables, and stores the result in another <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>.</p>
<p>This works by passing references to two DiscreteFunctions: the first, <code>inFun</code>, is the original function to be marginalised, and the second, <code>outFun</code>, is a function with a smaller domain, in which the result will be stored. The domain of <code>outFun</code> must not be larger than the domain of <code>inFun</code>, and any variables that are in the domain of <code>inFun</code>, but not in the domain of <code>outFun</code>, will be marginalised. This procedure is demonstrated in the following code. </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">VarID</a> vars = {1,2};
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> siz = {2,3}; // variable 1 has domain size 2, etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">registerVariables</a> (vars,vars+2,siz,siz+2);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> inFun(vars,vars+2);  // depends on variables 1 and 2
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> outFun(vars,vars+1); // depends on variable 1 only</pre><pre>inFun(0,0) = 1; // assign some values to inFun
inFun(1,1) = 2;
inFun(0,2) = 3;
inFun(1,0) = 4;
inFun(0,1) = 5;
inFun(1,2) = 6;</pre><pre><a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> (inFun,outFun); // max marginalise inFun and store result in outFun</pre><pre>val = outFun(0);  // val==5 (maximum value for variable 1=0 in inFun)
val = outFun(1);  // val==6 (maximum value for variable 1=1 in inFun)
</pre><p> The reason for this style is efficiency: by preallocating <code>outFun</code> to store the result, we do not need to not need to allocate temporary objects in memory, and if necessary, can reuse <code>outFun</code> to store the result of several similar marginalisations.</p>
<p>More generally, the maxsum library also provides a number marginalisation functions, which aggregate across the removed variables in different ways. These are summarised in the table below. However, only the <a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> function is actually required to implement the max-sum algorithm. See <a href="#maxsumcontroller">The MaxSumController Class</a> for details. </p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a219e2e817c1601121cdb149147c14abc" title="Marginalise a maxsum::DiscreteFunction by maximisation.">maxMarginal</a> </td><td>Marginalise by maximising across removed variables. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a3a82ee0162acb2c89417e5365be4f854" title="Marginalise a maxsum::DiscreteFunction by minimisation.">minMarginal</a> </td><td>Marginalise by minimising across removed variables. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a555aaedda317f2d7a06fedd8c0636d5c" title="Marginalise a maxsum::DiscreteFunction by averaging.">meanMarginal</a> </td><td>Marginalise by averaging across removed variables. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#ae48b4828eefae581abf6b475b8d8f60c" title="Marginalise a maxsum::DiscreteFunction using a specified aggregation function.">marginal</a> </td><td>Marginalise using a custom aggregation function. </td></tr>
</table>
<h3><a class="anchor" id="arithmetic_ops"></a>
Arithmetic Operations</h3>
<p>Arithmetric operations on <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s are provided by overloading the standardard arithmetric operators in C++, including <code>+</code>, <code>-</code>, and <code>*</code>. These operations are applied elementwise across the cartesian product of the operands' domains, as illustrated in the following example: </p>
<pre>
<a class="el" href="namespacemaxsum.html#a572e59b0c017dac30927fc445aa28216" title="Type used for uniquely identifying variables.">VarID</a> vars = {1,2};
<a class="el" href="namespacemaxsum.html#a2703843fa0f76002b3285d94f1693d26" title="Integer type used for indexing coefficient values.">ValIndex</a> siz = {2,3}; // variable 1 has domain size 2, etc.
<a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">registerVariables</a> (vars,vars+2,siz,siz+2);
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> f(vars,vars+1);   // depends only on variable 1
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> g(vars+1,vars+2); // depends only on variable 2
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> h(vars,vars+2);   // depends on variables 1 and 2</pre><pre>// assign some values
  f(0) = 1.0;   f(1) = 1.1;
  g(0) = 2.0;   g(1) = 2.1;   g(2) = 2.2;
h(0,0) = 3.0; h(0,1) = 3.1; h(0,2) = 3.2;
h(1,0) = 4.0; h(1,1) = 4.1; h(1,2) = 4.2;</pre><pre><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> x = f+g;
// x(0,0) == f(0) + g(0) == 1.0 + 2.0 == 3.0;
// x(1,0) == f(1) + g(0) == 1.1 + 2.0 == 3.1;
// ....
// x(1,2) == f(1) + g(2) == 1.1 + 2.2 == 3.3;</pre><pre><a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> y = f+h;
// y(0,0) == f(0) + h(0,0) == 1.0 + 3.0 == 4.0;
// y(1,0) == f(1) + h(1,0) == 1.1 + 4.0 == 5.1;
// ....
// y(1,2) == f(1) + h(1,2) == 1.1 + 4.2 == 5.3;
</pre><p> Here, notice that the domain of the results, <code>x</code> and <code>y</code>, are automatically set to the cartesian product of the domains of the operands. The following operations are all similarly defined. </p>
<table class="doxtable">
<tr>
<th>Operation</th><th>Description </th></tr>
<tr>
<td><code>f + g</code></td><td>Element-wise addition. </td></tr>
<tr>
<td><code>f - g</code></td><td>Element-wise subtraction. </td></tr>
<tr>
<td><code>f * g</code></td><td>Element-wise multiplication. </td></tr>
<tr>
<td><code>f += g</code></td><td>Element-wise addition, storing result in <code>f</code>. </td></tr>
<tr>
<td><code>f -= g</code></td><td>Element-wise subtraction, storing result in <code>f</code>. </td></tr>
<tr>
<td><code>f *= g</code></td><td>Element-wise multiplication, storing result in <code>f</code>. </td></tr>
<tr>
<td><code> -g</code></td><td>Unary Minus. </td></tr>
</table>
<p>The right operand, <code>g</code>, can also be replaced by a scalar value of any numeric type convertable to <a class="el" href="namespacemaxsum.html#add02fc7a161c705a735b15646b2b6733" title="Type of values stored by maxsum::DiscreteFunction objects.">ValType</a>. In this case, the scalar is operated on with each element in the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain e.g. </p>
<pre>
<a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> z = f + 100.5;
// z(0) == f(0) + 100.5 == 1.0 + 100.5 == 101.5
// z(1) == f(1) + 100.5 == 1.1 + 100.5 == 101.6
</pre><p> Since adding a number of DiscreteFunctions together is a common procedure, a member function <a class="el" href="classmaxsum_1_1_discrete_function.html#a3c9adbf572284ec843755691d34ded79" title="Adds a list of Functions to this one, expanding the domain if necessary.">DiscreteFunction::add</a> is also provided, which takes iterators to the start and end of a sequence of DiscreteFunctions, and adds them all to the current <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>, expanding its domain if necessary.</p>
<h2><a class="anchor" id="comparision_ops"></a>
Comparison Operations</h2>
<p>Equality between DiscreteFunctions can be defined in several ways, and for this reason the maxsum library provides three different functions for testing equality between <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> objects: </p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a15f2209735d087f5f25c68f9cb1778b0" title="Check that two maxsum::DiscreteFunction objects have the same domain.">sameDomain(const DiscreteFunction&amp; f1, const DiscreteFunction&amp; f2)</a></td><td>Returns true iff <code>f1</code> and <code>f2</code> have the same domain. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a6386d78723ee3d5d0202f05c2a3c7726" title="Check that two maxsum::DiscreteFunction objects are equal within a specified tolerance.">equalWithinTolerance(const DiscreteFunction&amp; f1, const DiscreteFunction&amp; f2, ValType tol)</a> </td><td>Returns true iff <code>f1</code> and <code>f2</code> are equal across the cartesian product of their domains, within a given tolerance, <code>tol</code>. </td></tr>
<tr>
<td><a class="el" href="namespacemaxsum.html#a0e6948dba163b8d6a51a41f2ea24a182" title="Check that two maxsum::DiscreteFunction objects are equal with a specified tolerance, and have exactly the same domain.">strictlyEqualWithinTolerance(const DiscreteFunction&amp; f1, const DiscreteFunction&amp; f2, ValType tol)</a> </td><td>Returns true iff <code>sameDomain(f1,f2) &amp;&amp; equalWithinTolerance(f1,f2,tol)</code> </td></tr>
</table>
<p>The functions <a class="el" href="namespacemaxsum.html#a6386d78723ee3d5d0202f05c2a3c7726" title="Check that two maxsum::DiscreteFunction objects are equal within a specified tolerance.">equalWithinTolerance</a> and <a class="el" href="namespacemaxsum.html#a0e6948dba163b8d6a51a41f2ea24a182" title="Check that two maxsum::DiscreteFunction objects are equal with a specified tolerance, and have exactly the same domain.">strictlyEqualWithinTolerance</a> are provided so that two DiscreteFunctions can be treated as equal in cases where their values differ only by some small rounding error. For cases in which strict equality is required between values is required (i.e. the error tolerance is 0), the standard equality and inequality operators may also be used: </p>
<table class="doxtable">
<tr>
<th>Operator</th><th>Definition </th></tr>
<tr>
<td><code>f1==f2</code></td><td><code>equalWithinTolerance(f1,f2,0)</code> </td></tr>
<tr>
<td><code>f1!=f2</code></td><td><code>!equalWithinTolerance(f1,f2,0)</code> </td></tr>
</table>
<h2><a class="anchor" id="misc_ops"></a>
Miscellaneous Operations</h2>
<p>The <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> class includes a number of members that do not directly relate to a <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s values, but instead provide meta data about the function, and enable various house keeping operations. These are summarised in the following table. </p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a4f0cb99d85930efbb6945e7e4de60197" title="Accessor method for the total size this function&#39;s domain.">DiscreteFunction::domainSize</a> </td><td>Returns the size of this <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain, defined as the product of the domain sizes for each variable in its domain. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a863f6c668486665117318c96e6e407d7" title="Returns the number of variables on which this function depends.">DiscreteFunction::noVars</a> </td><td>Returns the number of variables in this <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#aef0c2cd95197bf66b65a6df099069179" title="Returns true if this function depends on the specified variable.">DiscreteFunction::dependsOn</a> </td><td>Returns <code>true</code> if a specified variable is in this <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a27dbb69c84f206e251d6c80122a61888" title="Returns an iterator to the start of this function&#39;s domain variable list.">DiscreteFunction::varBegin</a> </td><td>Returns an iterator to the start of the list of variables in this <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a5551045d4c693a4d70ba4cd0984cd789" title="Returns an iterator to the end of this function&#39;s domain variable list.">DiscreteFunction::varEnd</a> </td><td>Returns an iterator to the end of the list of variables in this <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#a3dd0befdfa370727d737cee0da9d1c5b" title="Returns an iterator to the start of this function&#39;s domain variable size list.">DiscreteFunction::sizeBegin</a> </td><td>Returns an iterator to the start of a list of domain sizes, in which the kth element gives the domain size for the kth variable in this <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain. </td></tr>
<tr>
<td><a class="el" href="classmaxsum_1_1_discrete_function.html#ae3ba7896985decae2e3d369a6ff8321c" title="Returns an iterator to the end of this function&#39;s domain variable size list.">DiscreteFunction::sizeEnd</a> </td><td>Returns an iterator to the end of a list of domain sizes, in which the kth element gives the domain size for the kth variable in this <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a>'s domain. </td></tr>
</table>
<h1><a class="anchor" id="domainIterator"></a>
The DomainIterator Class</h1>
<p>Todo.</p>
<h1><a class="anchor" id="maxsumcontroller"></a>
The MaxSumController Class</h1>
<p><a class="el" href="classmaxsum_1_1_max_sum_controller.html" title="This class maintains a factor graph and implements the max-sum algorithm.">MaxSumController</a> is the main class responsible for implementing the max-sum algorithm, and providing its results. To run the algorithm using this class, the following steps are all that is required:</p>
<ol type="1">
<li>Register all variables in the factor graph using either <a class="el" href="namespacemaxsum.html#a373fa742a9678cc654e76384cb04d7b0" title="Registers a variable with a specified domain size.">registerVariable</a> or <a class="el" href="namespacemaxsum.html#a18bbaee58df9fdda98966952ad990c85" title="Register a list of variables with specified domain sizes.">registerVariables</a>.</li>
<li>Create a set of <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> objects, representing each factor in the target problem's factor graph.</li>
<li>Construct a new <a class="el" href="classmaxsum_1_1_max_sum_controller.html" title="This class maintains a factor graph and implements the max-sum algorithm.">MaxSumController</a> object, optionally specifying termination conditions.</li>
<li>Use the <a class="el" href="classmaxsum_1_1_max_sum_controller.html#a4cff3513f4d480dfa6dcd77f72c51d4d" title="Accessor method for factor function.">MaxSumController::setFactor</a> member function to specify the set of factors from the previously created list of <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> objects.</li>
<li>Call <a class="el" href="classmaxsum_1_1_max_sum_controller.html#ace444371d6159fba0fc1548bf9a2aeb2" title="Runs the max-sum algorithm to optimise the values for each variable.">MaxSumController::optimise</a> to run the max-sum algorithm</li>
<li>Use <a class="el" href="classmaxsum_1_1_max_sum_controller.html#a12c928d544373c3329c77fbff5522098" title="Returns a read only iterator to the beginning of the variable value map.">MaxSumController::valBegin</a> and <a class="el" href="classmaxsum_1_1_max_sum_controller.html#ab6ee62aefe2e6ece7999a3f5b9779a4d" title="Returns a read only iterator to the end of the variable value map.">MaxSumController::valEnd</a> to iterate through all variables in the factor graph, and retrieve there optimal values.</li>
</ol>
<p>For example, the following code illustrates how these steps may be implemented in practice: </p>
<pre>
using namespace maxsum;
std::vector&lt;VarID&gt; vars; // list of variables in factor graph
std::vector&lt;ValIndex&gt; sizes; // sizes[k] == domain size for vars[k]
// ... populate above containers with appropriate values
registerVariables(vars.begin(),vars.end(),sizes.begin(),sizes.end());</pre><pre>std::map&lt;FactorID,DiscreteFunction&gt; factors; // factors mapped to ids
// populate factors with DiscreteFunctions mapped to factor ids</pre><pre><a class="el" href="classmaxsum_1_1_max_sum_controller.html" title="This class maintains a factor graph and implements the max-sum algorithm.">MaxSumController</a> controller(100,0.0001); // new controller with custom stopping conditions
                                         // see <a class="el" href="classmaxsum_1_1_max_sum_controller.html#a6702ee30f5ae1730f20900262d01d16e" title="Construct a new maxsum::MaxSumController.">MaxSumController::MaxSumController</a> for details
// set up factor graph inside controller
// edges of graph are inferred automatically for factor domains
typedef std::map&lt;FactorID,DiscreteFunction&gt;::const_iterator Iterator;
for(Iterator it=factors.begin(); it!=factors.end(); ++it)
{
   controller.setFactor(it-&gt;first,it-&gt;second);
}</pre><pre>controller.optimise(); // run the max-sum algorithm</pre><pre>for(<a class="el" href="classmaxsum_1_1_max_sum_controller.html#a5074c6aa98e12286cb6cea9d69c22dcd" title="Read only iterator for all variable value assigments.">MaxSumController::ConstValueIterator</a> it=controller.valBegin();
    it!=controller.valEnd(); ++it)
{
   std::cout &lt;&lt; "Optimal value for variable " &lt;&lt; it-&gt;first
             &lt;&lt; " is " &lt;&lt; it-&gt;second &lt;&lt; std::endl;
}
</pre><p>In addition to these functions, <a class="el" href="classmaxsum_1_1_max_sum_controller.html" title="This class maintains a factor graph and implements the max-sum algorithm.">MaxSumController</a> class also provides a number of other member functions to set, change, and query the factor graph in different ways. These are particular useful in the problems were the factor values, or the shape of the factor graph can change over time. For further information, see the manual page for <a class="el" href="classmaxsum_1_1_max_sum_controller.html" title="This class maintains a factor graph and implements the max-sum algorithm.">MaxSumController</a>.</p>
<h1><a class="anchor" id="tips"></a>
Tips on Writing Efficient Code</h1>
<p>In general, the guidelines for writing efficient C++ code in any context also apply to code written using the maxsum library. In particular, one key piece of advice is to, as far as possible, avoid creating temporary objects in memory, when existing objects can be modified and reused.</p>
<p>One place where temporary objects are (currently) unavoidable is in the use of certain overloaded operators: </p>
<ul>
<li>The arithmetic operators, <code>+</code>, <code>-</code>, and <code>*</code> all create temporary objects to store their result </li>
<li>The postfix increment operator, <code>++</code>, returns a copy of its operand, before incrementing the operands value.</li>
</ul>
<p>We have plans to implement lazy evaluation, which would minimise the use of temporary objects, and improve performance in many instances. For now though, if you find you need more speed you may wish to consider the following <em>destructive</em> alternatives, which replace an operand's original value with the result: </p>
<table class="doxtable">
<tr>
<th>Operation</th><th>Efficient Alternative </th></tr>
<tr>
<td><code>it++</code></td><td><code>++it</code> </td></tr>
<tr>
<td><code>f = f + g</code></td><td><code>f+=g</code> </td></tr>
<tr>
<td><code>f = f - g</code></td><td><code>f-=g</code> </td></tr>
<tr>
<td><code>f = f * g</code></td><td><code>f*=g</code> </td></tr>
<tr>
<td><code>f = - f</code></td><td><code>f *= -1</code> </td></tr>
</table>
<p>When performing arithmetic with DiscreteFunctions, another useful technique to expand a function's domain to its final size, rather than allowing its domain to change incrementally with each operation. For example, suppose DiscreteFunctions <code>f</code>, <code>g</code> and <code>h</code> depend on the single variables 1, 2, and 3 respectively. Now consider the following code. </p>
<pre>
// f starts with domain {1} only
f += g; // f reallocated to expand domain to {1,2}
f += h; // f reallocated to expand domain to {1,2,3}
</pre><p> On the otherhand, if we know the final domain in advance, we can improve efficiency by doing the following: </p>
<pre>
VarID vars[] = {1,2,3};
f.expand(vars,vars+3); // domain of f is now {1,2,3}
f += g; // more efficient: no domain change necessary
f += h; 
</pre><h1><a class="anchor" id="futurework"></a>
Future Work</h1>
<p>Although the basic implementation of this library is now complete, this project is still under going its first phase of active development. Accurate results are thus not yet guarranteed, and in fact, bugs are very much still to be expected.</p>
<p>For now, our main priority is thus continued testing and debugging. Beyond that, we also plan to look at various options for optimising the code and improving the interface. For example, one option is to link to the <a href="http://eigen.tuxfamily.org">eigen3</a> linear algebra library, to take advantage of its hardware vectorisation. We are also considering lazy evaluation as an option for optimising overloaded operators for the <a class="el" href="classmaxsum_1_1_discrete_function.html" title="Class representing functions of sets of variables with discrete domains.">DiscreteFunction</a> class.</p>
<p>We will also continue to improve this documentation of the API. All comments and feedback welcome! </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 2 2013 08:48:20 for Max-Sum by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
